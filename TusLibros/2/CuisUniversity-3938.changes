

----STARTUP---- (4 November 2019 18:42:16) as /Users/cmurga/Downloads/macos64/CuisUniversity-3938.image!


!classRemoval: #Client stamp: 'cmmmmm 11/4/2019 18:42:47'!
Object subclass: #Client
	instanceVariableNames: 'password'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tus-Libros'!

!classRemoval: #Cart stamp: 'cmmmmm 11/4/2019 18:42:47'!
Object subclass: #Cart
	instanceVariableNames: 'client password books'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tus-Libros'!

!classRemoval: #Book stamp: 'cmmmmm 11/4/2019 18:42:48'!
Object subclass: #Book
	instanceVariableNames: 'isbn'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tus-Libros'!

!classRemoval: #CartTest stamp: 'cmmmmm 11/4/2019 18:42:48'!
TestCase subclass: #CartTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tus-Libros'!

TestCase subclass: #CartTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tus-Libros'!

!classDefinition: #CartTest category: #'Tus-Libros' stamp: 'cmmmmm 11/4/2019 18:42:52'!
TestCase subclass: #CartTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tus-Libros'!
!CartTest methodsFor: 'as yet unclassified' stamp: 'LS 10/29/2019 21:09:29'!
                    test01NuevoCarritoEsVacio

	| aCart aClient aPassword |
	aPassword := 'passwordExample'.
	aClient := Client with: aPassword.
	aCart := Cart withClient: aClient andPassword: aPassword.
	
	self assert: aCart isEmpty.! !
!CartTest methodsFor: 'as yet unclassified' stamp: 'LS 10/29/2019 21:25:30'!
                         test02CarritoConUnLibroNoEstaVacio

	| aCart aClient aPassword aBook aQuantity anISBNNumber |
	aPassword := 'passwordExample'.
	aClient := Client with: aPassword.
	aCart := Cart withClient: aClient andPassword: aPassword.
	
	anISBNNumber := 9780805511963.
	aBook := Book with: anISBNNumber.
	aQuantity := 1.
	
	aCart addToCart: aBook isbn quantity: aQuantity.
	
	self deny: aCart isEmpty.! !
!CartTest methodsFor: 'as yet unclassified' stamp: 'cmmmmm 10/31/2019 17:01:21'!
       test03ListarNuevoCarritoEsListaVacia

	| aCart aClient aPassword aList |
	
	aPassword := 'passwordExample'.
	aClient := Client with: aPassword.
	aCart := Cart withClient: aClient andPassword: aPassword.
	
	aList := aCart listCart.
	
	self assert: '0' equals: aList.! !
!CartTest methodsFor: 'as yet unclassified' stamp: 'cmmmmm 10/31/2019 17:00:34'!
  test04ListarCarritoConUnLibroContieneEseLibro

	| aCart aClient aPassword aBook aQuantity anISBNNumber aList theWantedList |
	aPassword := 'passwordExample'.
	aClient := Client with: aPassword.
	aCart := Cart withClient: aClient andPassword: aPassword.
	
	anISBNNumber := 9780805511963.
	aBook := Book with: anISBNNumber.
	aQuantity := 1.
	aCart addToCart: aBook quantity: aQuantity.
	
	aList := aCart listCart.
	theWantedList := '0','|', anISBNNumber asString , '|', aQuantity asString.
	
	self assert: theWantedList equals: aList.! !
!CartTest methodsFor: 'as yet unclassified' stamp: 'cmmmmm 10/31/2019 17:01:45'!
                       test05ListarCarritoCon2LibrosMuestraLos2Libros

	| aCart aClient aPassword aBook aBook2 aQuantity anISBNNumber anISBNNumber2 aList theWantedList |
	aPassword := 'passwordExample'.
	aClient := Client with: aPassword.
	aCart := Cart withClient: aClient andPassword: aPassword.
	
	anISBNNumber := 9780805511963.
	aBook := Book with: anISBNNumber.
	aQuantity := 1.
	aCart addToCart: aBook quantity: aQuantity.
	
	anISBNNumber2 := 9780805511969.
	aBook2 := Book with: anISBNNumber2.
	aQuantity := 1.
	aCart addToCart: aBook2 quantity: aQuantity.
	
	
	aList := aCart listCart.
	theWantedList := '0','|',anISBNNumber asString , '|', aQuantity asString, '|', anISBNNumber2 asString , '|', aQuantity asString.
	
	self assert: theWantedList equals: aList.! !
!CartTest methodsFor: 'as yet unclassified' stamp: 'cmmmmm 10/31/2019 17:03:24'!
  test06ListarCarritoCon2LibrosIgualesMuestra1LibroConCantidad2

	| aCart aClient aPassword aBook aQuantity anISBNNumber aList theWantedList |
	aPassword := 'passwordExample'.
	aClient := Client with: aPassword.
	aCart := Cart withClient: aClient andPassword: aPassword.
	
	anISBNNumber := 9780805511963.
	aBook := Book with: anISBNNumber.
	aQuantity := 2.
	aCart addToCart: aBook quantity: aQuantity.
	
	aList := aCart listCart.
	theWantedList := '0','|',anISBNNumber asString , '|', aQuantity asString.
	
	self assert: theWantedList equals: aList.! !

Object subclass: #Book
	instanceVariableNames: 'isbn'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tus-Libros'!

!classDefinition: #Book category: #'Tus-Libros' stamp: 'cmmmmm 11/4/2019 18:42:52'!
Object subclass: #Book
	instanceVariableNames: 'isbn'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tus-Libros'!
!Book methodsFor: 'initialization' stamp: 'LS 10/30/2019 16:31:08'!
     initializeWith: anISBNNumber 
	
	isbn := anISBNNumber.! !
!Book methodsFor: 'accessing' stamp: 'LS 10/29/2019 21:27:27'!
       isbn
	
	^isbn! !

"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!

Book class
	instanceVariableNames: ''!

!classDefinition: 'Book class' category: #'Tus-Libros' stamp: 'cmmmmm 11/4/2019 18:42:52'!
Book class
	instanceVariableNames: ''!
!Book class methodsFor: 'instance creation' stamp: 'LS 10/29/2019 21:26:44'!
                            with: anISBNNumber
	
	^self new initializeWith: anISBNNumber ! !

Object subclass: #Cart
	instanceVariableNames: 'client password books'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tus-Libros'!

!classDefinition: #Cart category: #'Tus-Libros' stamp: 'cmmmmm 11/4/2019 18:42:52'!
Object subclass: #Cart
	instanceVariableNames: 'client password books'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tus-Libros'!
!Cart methodsFor: 'initialization' stamp: 'LS 10/29/2019 21:32:34'!
         initializeWithClient: aClient andPassword: aPassword 
	
	client := aClient.
	password := aPassword.
	books := OrderedCollection new.! !
!Cart methodsFor: 'accessing' stamp: 'LS 10/29/2019 21:33:50'!
                         isEmpty
	^books isEmpty.! !
!Cart methodsFor: 'accessing' stamp: 'cmmmmm 10/31/2019 17:15:44'!
 listCart
	
	| aList |
	
	aList := '0'.
	
	books do: [:aBook | ((books occurrencesOf: aBook) > 1) ifTrue: [^aList := aList, '|', aBook isbn asString, '|', '2' ] ifFalse: [aList := aList, '|', aBook isbn asString, '|', '1'] ].
	
	^aList ! !
!Cart methodsFor: 'as yet unclassified' stamp: 'cmmmmm 10/31/2019 17:04:19'!
    addToCart: aBook quantity: aQuantity 
	
	aQuantity timesRepeat: [books add: aBook ]! !

"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!

Cart class
	instanceVariableNames: ''!

!classDefinition: 'Cart class' category: #'Tus-Libros' stamp: 'cmmmmm 11/4/2019 18:42:52'!
Cart class
	instanceVariableNames: ''!
!Cart class methodsFor: 'instance creation' stamp: 'LS 10/29/2019 21:12:32'!
                      withClient: aClient andPassword: aPassword

	
	^self new initializeWithClient: aClient andPassword: aPassword ! !

Object subclass: #Client
	instanceVariableNames: 'password'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tus-Libros'!

!classDefinition: #Client category: #'Tus-Libros' stamp: 'cmmmmm 11/4/2019 18:42:52'!
Object subclass: #Client
	instanceVariableNames: 'password'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tus-Libros'!
!Client methodsFor: 'initialization' stamp: 'LS 10/29/2019 21:11:49'!
          initializeWith: aPassword 
	
	password := aPassword.! !

"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!

Client class
	instanceVariableNames: ''!

!classDefinition: 'Client class' category: #'Tus-Libros' stamp: 'cmmmmm 11/4/2019 18:42:52'!
Client class
	instanceVariableNames: ''!
!Client class methodsFor: 'class initialization' stamp: 'LS 10/29/2019 21:11:02'!
          with: aPassword
	^self new initializeWith: aPassword ! !

----End fileIn of /Users/cmurga/Documents/Facultad/ejerciciosIS1/TusLibros/1/Tus-Libros.st----!

!classRemoval: #Client stamp: 'cmmmmm 11/4/2019 18:48:45'!
Object subclass: #Client
	instanceVariableNames: 'password'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tus-Libros'!

!classRemoval: #Cart stamp: 'cmmmmm 11/4/2019 18:48:45'!
Object subclass: #Cart
	instanceVariableNames: 'client password books'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tus-Libros'!

!classRemoval: #Book stamp: 'cmmmmm 11/4/2019 18:48:45'!
Object subclass: #Book
	instanceVariableNames: 'isbn'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tus-Libros'!

!classRemoval: #CartTest stamp: 'cmmmmm 11/4/2019 18:48:45'!
TestCase subclass: #CartTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tus-Libros'!

TestCase subclass: #CartTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #CartTest category: #TusLibros stamp: 'cmmmmm 11/4/2019 18:49:00'!
TestCase subclass: #CartTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!CartTest methodsFor: 'tests' stamp: 'HernanWilkinson 6/17/2013 17:08'!
                test01NewCartsAreCreatedEmpty

	self assert: self createCart isEmpty! !
!CartTest methodsFor: 'tests' stamp: 'HernanWilkinson 6/17/2013 17:45'!
                test02CanNotAddItemsThatDoNotBelongToStore

	| cart |
	
	cart := self createCart.
	
	self 
		should: [ cart add: self itemNotSellByTheStore ]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [ :anError |
			self assert: anError messageText = cart invalidItemErrorMessage.
			self assert: cart isEmpty ]! !
!CartTest methodsFor: 'tests' stamp: 'HernanWilkinson 6/17/2013 17:43'!
                              test03AfterAddingAnItemTheCartIsNotEmptyAnymore

	| cart |
	
	cart := self createCart.
	
	cart add: self itemSellByTheStore.
	self deny: cart isEmpty ! !
!CartTest methodsFor: 'tests' stamp: 'HernanWilkinson 6/17/2013 17:43'!
                              test04CanNotAddNonPositiveNumberOfItems

	| cart |
	
	cart := self createCart.
	
	self 
		should: [cart add: 0 of: self itemSellByTheStore ]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [ :anError |
			self assert: anError messageText = cart invalidQuantityErrorMessage.
			self assert: cart isEmpty ]! !
!CartTest methodsFor: 'tests' stamp: 'HernanWilkinson 6/17/2013 17:45'!
                           test05CanNotAddMoreThanOneItemNotSellByTheStore

	| cart |
	
	cart := self createCart.
	
	self 
		should: [cart add: 2 of: self itemNotSellByTheStore  ]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [ :anError |
			self assert: anError messageText = cart invalidItemErrorMessage.
			self assert: cart isEmpty ]! !
!CartTest methodsFor: 'tests' stamp: 'HernanWilkinson 6/17/2013 17:43'!
                   test06CartRemembersAddedItems

	| cart |
	
	cart := self createCart.
	
	cart add: self itemSellByTheStore.
	self assert: (cart includes: self itemSellByTheStore)! !
!CartTest methodsFor: 'tests' stamp: 'HernanWilkinson 6/17/2013 17:43'!
                   test07CartDoesNotHoldNotAddedItems

	| cart |
	
	cart := self createCart.
	
	self deny: (cart includes: self itemSellByTheStore)! !
!CartTest methodsFor: 'tests' stamp: 'HernanWilkinson 6/17/2013 17:45'!
                    test08CartRemembersTheNumberOfAddedItems

	| cart |
	
	cart := self createCart.
	
	cart add: 2 of: self itemSellByTheStore.
	self assert: (cart occurrencesOf: self itemSellByTheStore) = 2! !
!CartTest methodsFor: 'support' stamp: 'HernanWilkinson 6/17/2013 17:48'!
                       createCart
	
	^Cart acceptingItemsOf: self defaultCatalog! !
!CartTest methodsFor: 'support' stamp: 'HernanWilkinson 6/17/2013 17:43'!
                         defaultCatalog
	
	^ Array with: self itemSellByTheStore! !
!CartTest methodsFor: 'support' stamp: 'HernanWilkinson 6/17/2013 17:44'!
                           itemNotSellByTheStore
	
	^'invalidBook'! !
!CartTest methodsFor: 'support' stamp: 'HernanWilkinson 6/17/2013 17:43'!
           itemSellByTheStore
	
	^ 'validBook'! !

TestCase subclass: #CashierTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #CashierTest category: #TusLibros stamp: 'cmmmmm 11/4/2019 18:49:00'!
TestCase subclass: #CashierTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!CashierTest methodsFor: 'as yet unclassified' stamp: 'LS 10/31/2019 21:29:57'!
             test01NewCashierWith

	| aCashier aCatalog aCart |
	
	aCatalog := Dictionary new.
	aCashier := Cashier with: aCatalog.
	
	aCart := Cart acceptingItemsOf: (Array with: 'validBook').
		
	self should: [ aCashier checkOut: aCart ]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [ :anError |
			self assert: anError messageText = Cashier cartCanNotBeEmpty.
			]
		
		 ! !

Object subclass: #Cart
	instanceVariableNames: 'catalog items'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #Cart category: #TusLibros stamp: 'cmmmmm 11/4/2019 18:49:00'!
Object subclass: #Cart
	instanceVariableNames: 'catalog items'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!Cart methodsFor: 'error messages' stamp: 'HernanWilkinson 6/17/2013 17:45'!
                             invalidItemErrorMessage
	
	^'Item is not in catalog'! !
!Cart methodsFor: 'error messages' stamp: 'HernanWilkinson 6/17/2013 17:45'!
                           invalidQuantityErrorMessage
	
	^'Invalid number of items'! !
!Cart methodsFor: 'assertions' stamp: 'HernanWilkinson 6/17/2013 17:51'!
                          assertIsValidItem: anItem

	(catalog includes: anItem) ifFalse: [ self error: self invalidItemErrorMessage ]! !
!Cart methodsFor: 'assertions' stamp: 'HernanWilkinson 6/17/2013 17:51'!
       assertIsValidQuantity: aQuantity

	aQuantity strictlyPositive ifFalse: [ self error: self invalidQuantityErrorMessage ]! !
!Cart methodsFor: 'initialization' stamp: 'HernanWilkinson 6/17/2013 17:48'!
                        initializeAcceptingItemsOf: aCatalog

	catalog := aCatalog.
	items := OrderedCollection new.! !
!Cart methodsFor: 'queries' stamp: 'HernanWilkinson 6/17/2013 17:45'!
                          occurrencesOf: anItem

	^items occurrencesOf: anItem  ! !
!Cart methodsFor: 'testing' stamp: 'HernanWilkinson 6/17/2013 17:44'!
includes: anItem

	^items includes: anItem ! !
!Cart methodsFor: 'testing' stamp: 'HernanWilkinson 6/17/2013 17:44'!
           isEmpty
	
	^items isEmpty ! !
!Cart methodsFor: 'adding' stamp: 'HernanWilkinson 6/17/2013 17:44'!
                             add: anItem

	^ self add: 1 of: anItem ! !
!Cart methodsFor: 'adding' stamp: 'HernanWilkinson 6/17/2013 17:51'!
                add: aQuantity of: anItem

	self assertIsValidQuantity: aQuantity.
	self assertIsValidItem: anItem.

	1 to: aQuantity do: [ :aNumber | items add: anItem ]! !

"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!

Cart class
	instanceVariableNames: ''!

!classDefinition: 'Cart class' category: #TusLibros stamp: 'cmmmmm 11/4/2019 18:49:00'!
Cart class
	instanceVariableNames: ''!
!Cart class methodsFor: 'instance creation' stamp: 'HernanWilkinson 6/17/2013 17:48'!
         acceptingItemsOf: aCatalog

	^self new initializeAcceptingItemsOf: aCatalog ! !

Object subclass: #Cashier
	instanceVariableNames: 'dictionary catalog'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #Cashier category: #TusLibros stamp: 'cmmmmm 11/4/2019 18:49:00'!
Object subclass: #Cashier
	instanceVariableNames: 'dictionary catalog'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!Cashier methodsFor: 'initialization' stamp: 'LS 10/31/2019 21:25:20'!
                         initializeWith: aCatalog
	
	catalog := aCatalog.! !
!Cashier methodsFor: 'as yet unclassified' stamp: 'LS 10/31/2019 21:30:50'!
cartCanNotBeEmpty
	self shouldBeImplemented.! !
!Cashier methodsFor: 'as yet unclassified' stamp: 'LS 10/31/2019 21:31:35'!
    checkOut: aCart 
	self error: Cashier cartCanNotBeEmpty.! !

"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!

Cashier class
	instanceVariableNames: ''!

!classDefinition: 'Cashier class' category: #TusLibros stamp: 'cmmmmm 11/4/2019 18:49:00'!
Cashier class
	instanceVariableNames: ''!
!Cashier class methodsFor: 'instance creation' stamp: 'LS 10/31/2019 21:29:23'!
        cartCanNotBeEmpty
	^'cart can not be empty'! !
!Cashier class methodsFor: 'instance creation' stamp: 'LS 10/31/2019 21:24:37'!
 with: aDictionary 
	
	^self new initializeWith: aDictionary ! !

----End fileIn of /Users/cmurga/Documents/Facultad/ejerciciosIS1/TusLibros/TusLibros.st----!
!CashierTest methodsFor: 'as yet unclassified' stamp: 'cmmmmm 11/4/2019 18:50:46'!
               test02CheckoutACartWith1ElementIsCorrect

	| aCashier aCatalog aCart |
	
	aCatalog := Dictionary new.
	aCashier := Cashier with: aCatalog.
	
	aCart := Cart acceptingItemsOf: (Array with: 'validBook').
	
	aCart 
		
	self should: [ aCashier checkOut: aCart ]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [ :anError |
			self assert: anError messageText = Cashier cartCanNotBeEmpty.
			]
		
		 ! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'cmmmmm 11/4/2019 18:52:38' prior: 50332176!
      test02CheckoutACartWith1ElementIsCorrect

	| aCashier aCatalog aCart |
	
	aCatalog := Dictionary new.
	aCashier := Cashier with: aCatalog.
	
	aCart := Cart acceptingItemsOf: (Array with: 'validBook').
	
	aCart add: 123123123123.
		
	self should: [ aCashier checkOut: aCart ]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [ :anError |
			self assert: anError messageText = Cashier cartCanNotBeEmpty.
			]
		
		 ! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'cmmmmm 11/4/2019 18:54:37' prior: 50332192!
                    test02CheckoutACartWith1ElementIsCorrect

	| aCashier aCatalog aCart |
	
	aCatalog := Dictionary new.
	aCashier := Cashier with: aCatalog.
	
	aCart := Cart acceptingItemsOf: (Array with: 'validBook').
	
	aCart add: 123123123123.
	
	self assert: 100 equals: aCashier checkOut: aCart .	
	self should: [ aCashier checkOut: aCart ]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [ :anError |
			self assert: anError messageText = Cashier cartCanNotBeEmpty.
			]
		
		 ! !

TestCase subclass: #PortfolioTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classDefinition: #PortfolioTest category: #'Portfolio-Solucion' stamp: 'cmmmmm 11/4/2019 18:55:29'!
TestCase subclass: #PortfolioTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!
!PortfolioTest methodsFor: 'assertions' stamp: 'LS 10/17/2019 20:54:30'!
                          assertTransactionsOf: aPortfolio includes: aReceptiveAccount
	
	aReceptiveAccount transactions do: [:transaction | (aPortfolio transactions includes: transaction) ifFalse: [^false]].
	^true.! !
!PortfolioTest methodsFor: 'tests' stamp: 'HAW 5/25/2019 11:16:26'!
                          test01BalanceOfPortfolioWithoutAccountsIsZero

	self assert: 0 equals: Portfolio new balance! !
!PortfolioTest methodsFor: 'tests' stamp: 'HAW 5/25/2019 11:17:51'!
                            test02BalanceOfPortfolioWithOneAccountIsAccountBalance

	| account portfolio |
	
	account := ReceptiveAccount new.
	Deposit register: 100 on: account.
	portfolio := Portfolio with: account.
	
	self assert: account balance equals: portfolio balance! !
!PortfolioTest methodsFor: 'tests' stamp: 'HAW 5/25/2019 11:23:25'!
 test03BalanceOfPortfolioIsCalculatedRecursivelyOnPortfolios

	| simplePortfolioAccount simplePortfolio composedPortfolioAccount composedPortofolio |
	
	simplePortfolioAccount := ReceptiveAccount new.
	Deposit register: 100 on: simplePortfolioAccount.
	simplePortfolio := Portfolio with: simplePortfolioAccount.
	
	composedPortfolioAccount := ReceptiveAccount new.
	Withdraw register: 50 on: composedPortfolioAccount.
	composedPortofolio := Portfolio with: simplePortfolio with: composedPortfolioAccount.
	
	self assert: (composedPortfolioAccount balance + simplePortfolio balance) equals: composedPortofolio balance! !
!PortfolioTest methodsFor: 'tests' stamp: 'HAW 5/25/2019 11:43:15'!
                 test04PortfolioWithoutAccountsHasNoRegisteredTransaction

	self deny: (Portfolio new hasRegistered: (Deposit for: 100))! !
!PortfolioTest methodsFor: 'tests' stamp: 'HAW 5/25/2019 11:43:11'!
 test05PortfolioHasRegisteredItsAccountsTransactions

	| account portfolio deposit |
	
	account := ReceptiveAccount new.
	deposit := Deposit register: 100 on: account.
	portfolio := Portfolio with: account.
	
	self assert: (portfolio hasRegistered: deposit)! !
!PortfolioTest methodsFor: 'tests' stamp: 'HAW 5/25/2019 11:58:06'!
                        test06PortfolioLooksForRegisteredTransactionsRecursively

	| simplePortfolioAccount simplePortfolio composedPortfolioAccount composedPortfolio composedPortfolioAccountWithdraw simplePortfolioAccountDeposit |
	
	simplePortfolioAccount := ReceptiveAccount new.
	simplePortfolioAccountDeposit := Deposit register: 100 on: simplePortfolioAccount.
	simplePortfolio := Portfolio with: simplePortfolioAccount.
	
	composedPortfolioAccount := ReceptiveAccount new.
	composedPortfolioAccountWithdraw := Withdraw register: 50 on: composedPortfolioAccount.
	composedPortfolio := Portfolio with: simplePortfolio with: composedPortfolioAccount.
	
	self assert: (composedPortfolio hasRegistered: simplePortfolioAccountDeposit).
	self assert: (composedPortfolio hasRegistered: composedPortfolioAccountWithdraw)! !
!PortfolioTest methodsFor: 'tests' stamp: 'HAW 5/25/2019 11:58:10'!
                              test07PortfolioHasNoTransactionWhenHasNoAccounts

	self assert: Portfolio new transactions isEmpty! !
!PortfolioTest methodsFor: 'tests' stamp: 'HAW 5/25/2019 11:58:15'!
                      test08PortfolioTransasctionsIncludesAllItsAccountsTransactions

	| account portfolio accountDeposit anotherAccount portfolioTransactions anotherAccountWithdraw |
	
	account := ReceptiveAccount new.
	accountDeposit := Deposit register: 100 on: account.
	anotherAccount := ReceptiveAccount new.
	anotherAccountWithdraw := Withdraw register: 100 on: account.
	portfolio := Portfolio with: account.
	
	portfolioTransactions := portfolio transactions.
	
	self assert: 2 equals: portfolioTransactions size.
	self assert: (portfolioTransactions includes: accountDeposit).
	self assert: (portfolioTransactions includes: anotherAccountWithdraw)! !
!PortfolioTest methodsFor: 'tests' stamp: 'HAW 5/25/2019 11:58:20'!
                             test09PortfolioTransactionsAreCalculatedRecursively

	| simplePortfolioAccount simplePortfolio composedPortfolioAccount composedPortfolio composedPortfolioAccountWithdraw simplePortfolioAccountDeposit composedPortfolioTransactions |
	
	simplePortfolioAccount := ReceptiveAccount new.
	simplePortfolioAccountDeposit := Deposit register: 100 on: simplePortfolioAccount.
	simplePortfolio := Portfolio with: simplePortfolioAccount.
	
	composedPortfolioAccount := ReceptiveAccount new.
	composedPortfolioAccountWithdraw := Withdraw register: 50 on: composedPortfolioAccount.
	composedPortfolio := Portfolio with: simplePortfolio with: composedPortfolioAccount.
	
	composedPortfolioTransactions := composedPortfolio transactions.
	self assert: 2 equals: composedPortfolioTransactions size.
	self assert: (composedPortfolioTransactions includes: simplePortfolioAccountDeposit).
	self assert: (composedPortfolioTransactions includes: composedPortfolioAccountWithdraw)! !
!PortfolioTest methodsFor: 'tests' stamp: 'HAW 5/25/2019 11:58:24'!
                         test10PortfolioCanNotIncludeTheSameAccountMoreThanOnce

	| account portfolio |
	
	account := ReceptiveAccount new.
	portfolio := Portfolio with: account.
	
	self 
		should: [ portfolio add: account ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: Portfolio canNotAddAccountErrorMessage equals: anError messageText.
			self assert: 1 equals: portfolio accountsSize.
			self assert: (portfolio accountsIncludes: account) ]! !
!PortfolioTest methodsFor: 'tests' stamp: 'HAW 5/25/2019 11:58:28'!
            test11PortfolioCanNotIncludeAccountOfItsPortfolios

	| account simplePortfolio composedPortfolio |
	
	account := ReceptiveAccount new.
	simplePortfolio := Portfolio with: account.
	composedPortfolio := Portfolio with: simplePortfolio.
	
	self 
		should: [ composedPortfolio add: account ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: Portfolio canNotAddAccountErrorMessage equals: anError messageText.
			self assert: 1 equals: composedPortfolio accountsSize.
			self assert: (composedPortfolio accountsIncludes: simplePortfolio) ]! !
!PortfolioTest methodsFor: 'tests' stamp: 'HAW 5/25/2019 11:58:32'!
                           test12PortfolioCanNotIncludeItself

	| account simplePortfolio |
	
	account := ReceptiveAccount new.
	simplePortfolio := Portfolio with: account.
	
	self 
		should: [ simplePortfolio add: simplePortfolio ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: Portfolio canNotAddAccountErrorMessage equals: anError messageText.
			self assert: 1 equals: simplePortfolio accountsSize.
			self assert: (simplePortfolio accountsIncludes: account) ]! !
!PortfolioTest methodsFor: 'tests' stamp: 'HAW 5/25/2019 12:01:51'!
                          test13ComposedPortfolioCanNotHaveParentPortfolioAccount

	| account simplePortfolio composedPortfolio |
	
	account := ReceptiveAccount new.
	simplePortfolio := Portfolio new.
	composedPortfolio := Portfolio with: simplePortfolio.
	composedPortfolio add: account.
	
	self 
		should: [ simplePortfolio add: account ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: Portfolio canNotAddAccountErrorMessage equals: anError messageText.
			self assert: simplePortfolio accountsIsEmpty ]! !
!PortfolioTest methodsFor: 'tests' stamp: 'HAW 5/25/2019 12:12:16'!
                 test14ComposedPortfolioCanNotHaveAccountOfAnyRootParentRecursively

	| account leftParentPortfolio leftRootParentPortfolio portfolio rightParentPortfolio rightRootParentPortfolio |
	
	account := ReceptiveAccount new.
	portfolio := Portfolio new.
	leftParentPortfolio := Portfolio with: portfolio .
	leftRootParentPortfolio := Portfolio with: leftParentPortfolio.
	leftRootParentPortfolio add: account.
	
	rightParentPortfolio := Portfolio with: portfolio .
	rightRootParentPortfolio := Portfolio with: rightParentPortfolio.
	rightRootParentPortfolio add: account.

	self 
		should: [ portfolio add: account ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: Portfolio canNotAddAccountErrorMessage equals: anError messageText.
			self assert: portfolio accountsIsEmpty ]! !
!PortfolioTest methodsFor: 'tests' stamp: 'HAW 5/29/2019 16:31:18'!
                 test15PortfolioCanNotIncludeAnyOfTheComposedAccountOfPortfolioToAdd

	| portfolioToAdd portfolioToModify rootPortfolio sharedAccount |
	
	sharedAccount := ReceptiveAccount new.
	portfolioToModify := Portfolio new.
	rootPortfolio := Portfolio with: sharedAccount with: portfolioToModify.
	portfolioToAdd := Portfolio with: sharedAccount.
	
	self 
		should: [ portfolioToModify add: portfolioToAdd ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError | 
			self assert: Portfolio canNotAddAccountErrorMessage equals: anError messageText.
			self assert: portfolioToModify accountsIsEmpty ]! !

TestCase subclass: #ReceptiveAccountTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classDefinition: #ReceptiveAccountTest category: #'Portfolio-Solucion' stamp: 'cmmmmm 11/4/2019 18:55:29'!
TestCase subclass: #ReceptiveAccountTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!
!ReceptiveAccountTest methodsFor: 'tests' stamp: 'HAW 5/23/2019 15:19:48'!
test01ReceptiveAccountHaveZeroAsBalanceWhenCreated 

	| account |
	
	account := ReceptiveAccount new.

	self assert: 0 equals: account balance .
! !
!ReceptiveAccountTest methodsFor: 'tests' stamp: 'HAW 5/23/2019 15:19:54'!
test02DepositIncreasesBalanceOnTransactionValue 

	| account |
	
	account := ReceptiveAccount  new.
	Deposit register: 100 on: account.
		
	self assert: 100 equals: account balance .
! !
!ReceptiveAccountTest methodsFor: 'tests' stamp: 'HAW 5/23/2019 15:20:02'!
                          test03WithdrawDecreasesBalanceOnTransactionValue 

	| account |
	
	account := ReceptiveAccount new.
	Deposit register: 100 on: account.
	Withdraw register: 50 on: account.
		
	self assert: 50 equals: account balance .
! !
!ReceptiveAccountTest methodsFor: 'tests' stamp: 'HAW 5/23/2019 15:20:32'!
                       test04WithdrawValueMustBePositive 

	| account withdrawValue |
	
	account := ReceptiveAccount new.
	withdrawValue := 50.
	
	self assert: withdrawValue equals: (Withdraw register: withdrawValue on: account) value
! !
!ReceptiveAccountTest methodsFor: 'tests' stamp: 'HAW 5/23/2019 15:20:46'!
                             test05ReceptiveAccountKnowsRegisteredTransactions 

	| account deposit withdraw |
	
	account := ReceptiveAccount new.
	deposit := Deposit register: 100 on: account.
	withdraw := Withdraw register: 50 on: account.
		
	self assert: (account hasRegistered: deposit).
	self assert: (account hasRegistered: withdraw).
! !
!ReceptiveAccountTest methodsFor: 'tests' stamp: 'HAW 5/23/2019 15:20:54'!
                        test06ReceptiveAccountDoNotKnowNotRegisteredTransactions

	| account deposit withdraw |
	
	account := ReceptiveAccount new.
	deposit :=  Deposit for: 100.
	withdraw := Withdraw for: 50.
		
	self deny: (account hasRegistered: deposit).
	self deny: (account hasRegistered:withdraw).
! !
!ReceptiveAccountTest methodsFor: 'tests' stamp: 'HAW 5/23/2019 15:21:24'!
                        test07AccountKnowsItsTransactions 

	| account1 deposit1 |
	
	account1 := ReceptiveAccount new.
	
	deposit1 := Deposit register: 100 on: account1.
		
	self assert: 1 equals: account1 transactions size .
	self assert: (account1 transactions includes: deposit1).
! !

TestCase subclass: #TransferenceTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classDefinition: #TransferenceTest category: #'Portfolio-Solucion' stamp: 'cmmmmm 11/4/2019 18:55:29'!
TestCase subclass: #TransferenceTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!
!TransferenceTest methodsFor: 'tests' stamp: 'LS 10/22/2019 16:40:52'!
        test01MakingATransferMakesADepositAndWithdraw

	| accountSource accountDestiny deposit |
	
	accountSource := ReceptiveAccount new.
	accountDestiny := ReceptiveAccount new.
	deposit := Deposit register: 100 on: accountSource .
	
	Transference from: accountSource to: accountDestiny of: 10.		
	
	self assert: 90 equals: accountSource balance.
	self assert: 10 equals: accountDestiny balance.! !
!TransferenceTest methodsFor: 'tests' stamp: 'LS 10/22/2019 17:18:49'!
                test02CannotMakeANegativeTransaction

	| accountSource accountDestiny deposit |
	
	accountSource := ReceptiveAccount new.
	accountDestiny := ReceptiveAccount new.
	deposit := Deposit register: 100 on: accountSource .
	
		self 
		should: [ Transference from: accountSource to: accountDestiny of: -10. ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: Transference cannotTransferNegativeAmount equals: anError messageText.
			self assert: 100 equals: accountSource balance.
			self assert: 0 equals: accountDestiny balance. ]! !
!TransferenceTest methodsFor: 'tests' stamp: 'LS 10/22/2019 16:40:52'!
   test03ValueOfTransactionIsCorrect

	| accountSrc accountDst transactionValue deposit |
	
	accountSrc := ReceptiveAccount new.
	accountDst := ReceptiveAccount new.
	deposit := Deposit register: 100 on: accountSrc.
	transactionValue := 10.
	
	self assert: transactionValue equals: (Transference from: accountSrc to: accountDst of: transactionValue ) value
! !
!TransferenceTest methodsFor: 'tests' stamp: 'LS 10/22/2019 16:40:52'!
                   test04BalanceOfTransactionIsCorrect

	| accountSrc accountDst transactionValue deposit |
	
	accountSrc := ReceptiveAccount new.
	accountDst := ReceptiveAccount new.
	deposit := Deposit register: 100 on: accountSrc.
	transactionValue := 10.
	Transference from: accountSrc to: accountDst of: transactionValue.
	
	self assert: 90 equals: accountSrc balance.
	self assert: 10 equals: accountDst balance.! !
!TransferenceTest methodsFor: 'tests' stamp: 'LS 10/28/2019 15:45:56'!
      test05MakeAReportOfAnEmptyAccount

	| accountSrc report |
	
	accountSrc := ReceptiveAccount new.
	report := Report with: accountSrc.
	
	self assert: 'Balance = 0' equals: report makeReport.
	! !
!TransferenceTest methodsFor: 'tests' stamp: 'LS 10/28/2019 15:46:40'!
                      test06MakeAReportOfAnAccountWithADeposit

	| deposit account report |
	
	account := ReceptiveAccount new.
	deposit := Deposit register: 100 on: account.
	report := Report with: account.	
	
	self assert: 'Deposito por 100. Balance = 100' equals: report makeReport.
	! !
!TransferenceTest methodsFor: 'tests' stamp: 'LS 10/28/2019 15:50:45'!
            test07MakeAReportOfAnAccountWithADepositAndAWithdraw

	| deposit account withdraw report|
	
	account := ReceptiveAccount new.
	deposit := Deposit register: 100 on: account.	
	withdraw := Withdraw register: 20 on: account.
	report := Report with: account.	
	
	self assert: 'Deposito por 100. Extraccion por 20. Balance = 80' equals: report makeReport.
	! !
!TransferenceTest methodsFor: 'tests' stamp: 'LS 10/28/2019 15:47:47'!
                     test08MakeAReportOfAnEmptyPortfolio

	| portfolio account report |
	
	account := ReceptiveAccount new.
	portfolio := Portfolio with: account.	
	report := Report with: portfolio.
	
	self assert: 'Balance = 0' equals: report makeReport.
	! !
!TransferenceTest methodsFor: 'tests' stamp: 'LS 10/28/2019 15:49:23'!
         test09MakeAReportOfAnAccountWithADepositAndATransaction

	| deposit accountSrc accountDst transaction reportSrc reportDst |
	
	accountSrc := ReceptiveAccount new.
	accountDst := ReceptiveAccount new.
	deposit := Deposit register: 100 on: accountSrc.
	Transference from: accountSrc to: accountDst of: 20.
	
	reportSrc := Report with: accountSrc.
	reportDst := Report with: accountDst.
	
	self assert: 'Deposito por 100. Salida por Transferencia de 20. Balance = 80' equals: reportSrc makeReport.
	self assert: 'Entrada por Transferencia de 20. Balance = 20' equals: reportDst makeReport.
	! !
!TransferenceTest methodsFor: 'tests' stamp: 'LS 10/28/2019 15:49:57'!
         test10MakeAReportOfAPortfolioWithOneAccountWithADepositAndWithdraw

	| portfolio deposit account withdraw report |
	
	account := ReceptiveAccount new.
	deposit := Deposit register: 100 on: account.	
	withdraw := Withdraw register: 20 on: account.
	portfolio := Portfolio with: account.
	
	report := Report with: portfolio .	
	
	self assert: 'Deposito por 100. Extraccion por 20. Balance = 80' equals: report makeReport.
	! !
!TransferenceTest methodsFor: 'tests' stamp: 'LS 10/28/2019 16:35:10'!
                test11TransferNetOfAnEmptyAccountIsZero

	| account transferNet |
	
	account := ReceptiveAccount new.
	transferNet := TransferNet with: account.
	
	self assert: 0 equals: transferNet printTransferNet.
	! !
!TransferenceTest methodsFor: 'tests' stamp: 'LS 10/28/2019 16:36:34'!
           test12TransferNetOfAnAccountsWithATransferenceIsCorrect

	| accountSrc accountDst deposit transactionValue transferNetSrc transferNetDst |
	
	accountSrc := ReceptiveAccount new.
	accountDst := ReceptiveAccount new.
	
	deposit := Deposit register: 100 on: accountSrc.
	transactionValue := 10.
	Transference from: accountSrc to: accountDst of: transactionValue.
	
	transferNetSrc := TransferNet with: accountSrc.
	transferNetDst := TransferNet with: accountDst.
		
	self assert: transactionValue negated equals: transferNetSrc printTransferNet .
	self assert: transactionValue equals: transferNetDst printTransferNet .! !
!TransferenceTest methodsFor: 'tests' stamp: 'LS 10/28/2019 16:37:16'!
             test13TransferNetOfAnEmptyPortfolioIsZero

	| portfolio transferNet |
	
	portfolio := Portfolio new.
	transferNet := TransferNet with: portfolio .
	
	self assert: 0 equals: transferNet printTransferNet.
	! !
!TransferenceTest methodsFor: 'tests' stamp: 'LS 10/28/2019 16:45:33'!
         test14TransferNetOfAPortfolioWithAnAccountsWithATransferenceIsCorrect

	| accountSrc accountDst deposit transactionValue portfolioSrc portfolioDst transferNetAccSrc transferNetAccDst transferNetPortSrc transferNetPortDst |
	
	accountSrc := ReceptiveAccount new.
	accountDst := ReceptiveAccount new.
	
	deposit := Deposit register: 100 on: accountSrc.
	transactionValue := 10.
	Transference from: accountSrc to: accountDst of: transactionValue.
	
	portfolioSrc := Portfolio with: accountSrc.
	portfolioDst := Portfolio with: accountDst.
	
	transferNetAccSrc  := TransferNet with: accountSrc .
	transferNetAccDst := TransferNet with: accountDst .
	transferNetPortSrc := TransferNet with: portfolioSrc .
	transferNetPortDst := TransferNet with: portfolioDst .
	
	self assert: transferNetAccSrc printTransferNet equals: transferNetPortSrc printTransferNet .
	self assert: transferNetAccDst printTransferNet equals: transferNetPortDst printTransferNet.! !

Object subclass: #Account
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classDefinition: #Account category: #'Portfolio-Solucion' stamp: 'cmmmmm 11/4/2019 18:55:29'!
Object subclass: #Account
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!
!Account methodsFor: 'testing' stamp: 'HAW 5/25/2019 12:23:47'!
hasRegistered: aTransaction

	self subclassResponsibility ! !
!Account methodsFor: 'testing' stamp: 'HAW 5/25/2019 12:24:25'!
  isComposedBy: anAccount

	self subclassResponsibility ! !
!Account methodsFor: 'balance' stamp: 'HAW 5/25/2019 12:23:40'!
      balance

	self subclassResponsibility ! !
!Account methodsFor: 'transactions' stamp: 'HAW 5/25/2019 12:23:27'!
                 addTransactionsTo: aCollectionOfTransactions

	self subclassResponsibility ! !
!Account methodsFor: 'transactions' stamp: 'HAW 5/25/2019 12:23:15'!
            transactions

	self subclassResponsibility ! !
!Account methodsFor: 'transactions' stamp: 'LS 10/28/2019 16:56:39'!
            transferNet: aTransferNet
	^self subclassResponsibility ! !
!Account methodsFor: 'composition' stamp: 'HAW 5/25/2019 12:24:04'!
addedTo: aPortfolio

	self subclassResponsibility ! !

Account subclass: #Portfolio
	instanceVariableNames: 'accounts parents'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classDefinition: #Portfolio category: #'Portfolio-Solucion' stamp: 'cmmmmm 11/4/2019 18:55:29'!
Account subclass: #Portfolio
	instanceVariableNames: 'accounts parents'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!
!Portfolio methodsFor: 'transFernet' stamp: 'LS 10/28/2019 16:41:45'!
                   transferNet: aTransferNet
	^accounts do: [ :anAccount | anAccount transferNet: aTransferNet ]! !
!Portfolio methodsFor: 'report' stamp: 'LS 10/28/2019 17:21:11'!
                              reportOperations: aReport
	
	accounts do: [ :anAccount | anAccount reportOperations: aReport ].
! !
!Portfolio methodsFor: 'accounts management' stamp: 'HAW 5/25/2019 11:49:20'!
              accountsIncludes: anAccount

	^accounts includes: anAccount ! !
!Portfolio methodsFor: 'accounts management' stamp: 'HAW 5/25/2019 12:05:04'!
                  accountsIsEmpty
	
	^accounts isEmpty ! !
!Portfolio methodsFor: 'accounts management' stamp: 'HAW 5/25/2019 11:49:06'!
         accountsSize
	
	^accounts size! !
!Portfolio methodsFor: 'accounts management' stamp: 'HAW 5/25/2019 12:19:20'!
                add: accountToAdd

	self assertCanAdd: accountToAdd.
		
	accounts add: accountToAdd.
	accountToAdd addedTo: self 
	! !
!Portfolio methodsFor: 'accounts management' stamp: 'HAW 5/25/2019 12:17:31'!
                           rootParents
	
	| rootParents |
	
	rootParents := Set new.
	self addRootParentsTo: rootParents.
	
	^ rootParents! !
!Portfolio methodsFor: 'initialization' stamp: 'HAW 5/25/2019 12:03:18'!
    initialize

	accounts := OrderedCollection new.
	parents := OrderedCollection new.! !
!Portfolio methodsFor: 'balance' stamp: 'HAW 5/25/2019 11:19:36'!
        balance
	
	^accounts sum: [ :anAccount | anAccount balance ] ifEmpty: [ 0 ]! !
!Portfolio methodsFor: 'transactions' stamp: 'HAW 5/25/2019 11:42:55'!
          addTransactionsTo: aCollectionOfTransactions

	accounts do: [ :anAccount | anAccount addTransactionsTo: aCollectionOfTransactions ]! !
!Portfolio methodsFor: 'transactions' stamp: 'HAW 5/25/2019 11:38:32'!
                  transactions
	
	| transactions |
	
	transactions := OrderedCollection new.
	accounts do: [ :anAccount | anAccount addTransactionsTo: transactions ].
	
	^transactions ! !
!Portfolio methodsFor: 'composition' stamp: 'HAW 5/25/2019 12:02:59'!
                addedTo: aPortfolio 
	
	parents add: aPortfolio ! !
!Portfolio methodsFor: 'testing' stamp: 'HAW 5/25/2019 12:20:56'!
          anyRootParentIsComposedBy: accountToAdd

	^self rootParents anySatisfy: [ :aParent | aParent isComposedBy: accountToAdd]! !
!Portfolio methodsFor: 'testing' stamp: 'HAW 5/25/2019 11:28:29'!
  hasRegistered: aTransaction

	^accounts anySatisfy: [ :anAccount | anAccount hasRegistered: aTransaction ]! !
!Portfolio methodsFor: 'testing' stamp: 'HAW 5/29/2019 16:24:54'!
                isComposedBy: anAccount

	^ self = anAccount or: [ accounts anySatisfy: [ :composedAccount | (composedAccount isComposedBy: anAccount) or: [ anAccount isComposedBy: composedAccount ]]]! !
!Portfolio methodsFor: 'account management - private' stamp: 'HAW 5/25/2019 12:17:31'!
             addRootParentsTo: rootParents

	parents 
		ifEmpty: [ rootParents add: self ] 
		ifNotEmpty: [ parents do: [ :aParent | aParent addRootParentsTo: rootParents ]]! !
!Portfolio methodsFor: 'account management - private' stamp: 'HAW 5/25/2019 12:20:36'!
     assertCanAdd: accountToAdd

	(self anyRootParentIsComposedBy: accountToAdd) ifTrue: [ self signalCanNotAddAccount ].
! !
!Portfolio methodsFor: 'account management - private' stamp: 'HAW 5/25/2019 11:48:34'!
                signalCanNotAddAccount
	
	self error: self class canNotAddAccountErrorMessage! !

"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!

Portfolio class
	instanceVariableNames: ''!

!classDefinition: 'Portfolio class' category: #'Portfolio-Solucion' stamp: 'cmmmmm 11/4/2019 18:55:29'!
Portfolio class
	instanceVariableNames: ''!
!Portfolio class methodsFor: 'error handling' stamp: 'cmmmm 10/17/2019 19:15:20'!
accountAlreadyExists
	^'account Already Exists'! !
!Portfolio class methodsFor: 'error handling' stamp: 'cmmmm 10/17/2019 19:55:10'!
                           portfolioAlreadyExists
	^'portfolio alredy exists'! !
!Portfolio class methodsFor: 'as yet unclassified' stamp: 'HAW 5/25/2019 11:48:55'!
                      canNotAddAccountErrorMessage
	
	^'Can not add repeated account to a portfolio'! !
!Portfolio class methodsFor: 'as yet unclassified' stamp: 'HAW 5/25/2019 11:18:21'!
                          with: anAccount

	^self new 
		add: anAccount;
		yourself! !
!Portfolio class methodsFor: 'as yet unclassified' stamp: 'HAW 5/25/2019 11:23:59'!
               with: anAccount with: anotherAccount

	^self new 
		add: anAccount;
		add: anotherAccount;
		yourself! !

Account subclass: #ReceptiveAccount
	instanceVariableNames: 'transactions'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classDefinition: #ReceptiveAccount category: #'Portfolio-Solucion' stamp: 'cmmmmm 11/4/2019 18:55:29'!
Account subclass: #ReceptiveAccount
	instanceVariableNames: 'transactions'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!
!ReceptiveAccount methodsFor: 'initialization' stamp: 'HernanWilkinson 7/13/2011 18:35'!
initialize

	super initialize.
	transactions := OrderedCollection new.! !
!ReceptiveAccount methodsFor: 'transactions' stamp: 'HAW 5/25/2019 11:38:52'!
        addTransactionsTo: aCollectionOfTransactions

	aCollectionOfTransactions addAll: transactions ! !
!ReceptiveAccount methodsFor: 'transactions' stamp: 'HernanWilkinson 7/13/2011 18:37'!
       register: aTransaction

	transactions add: aTransaction 
! !
!ReceptiveAccount methodsFor: 'transactions' stamp: 'HernanWilkinson 7/13/2011 18:37'!
            transactions 

	^ transactions copy! !
!ReceptiveAccount methodsFor: 'transactions' stamp: 'LS 10/28/2019 17:07:37'!
           transferNet: aTransferNet
	transactions do: [:aTransaction | aTransaction doTransferNet: aTransferNet]
	! !
!ReceptiveAccount methodsFor: 'balance' stamp: 'HAW 5/25/2019 11:24:46'!
           balance

	^transactions 
		inject: 0
		into: [ :currentBalance :transaction | transaction affectBalance: currentBalance ]! !
!ReceptiveAccount methodsFor: 'testing' stamp: 'NR 10/21/2019 18:55:56'!
                          hasRegistered: aTransaction

	^ transactions includes: aTransaction 
! !
!ReceptiveAccount methodsFor: 'testing' stamp: 'HAW 5/25/2019 11:54:51'!
              isComposedBy: anAccount

	^self = anAccount ! !
!ReceptiveAccount methodsFor: 'composition' stamp: 'HAW 5/25/2019 12:03:32'!
   addedTo: aPortfolio 
	
	! !
!ReceptiveAccount methodsFor: 'report' stamp: 'LS 10/28/2019 17:19:47'!
                            reportOperations: aReport
	
	transactions do:[ :aTransaction | aTransaction addToReport: aReport ].! !

Object subclass: #AccountTransaction
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classDefinition: #AccountTransaction category: #'Portfolio-Solucion' stamp: 'cmmmmm 11/4/2019 18:55:29'!
Object subclass: #AccountTransaction
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!
!AccountTransaction methodsFor: 'value' stamp: 'cmmmm 10/17/2019 19:28:36'!
   updateBalance: aBalance

	^self subclassResponsibility ! !
!AccountTransaction methodsFor: 'value' stamp: 'HernanWilkinson 9/12/2011 12:25'!
                   value 

	self subclassResponsibility ! !
!AccountTransaction methodsFor: 'balance' stamp: 'LS 10/28/2019 17:01:51'!
            addToReport: aReport
	^self subclassResponsibility ! !
!AccountTransaction methodsFor: 'balance' stamp: 'HAW 5/25/2019 11:25:39'!
                              affectBalance: aBalance

	self subclassResponsibility ! !
!AccountTransaction methodsFor: 'transferNet' stamp: 'LS 10/28/2019 16:27:48'!
                       doTransferNet: aTranferNet
	^self subclassResponsibility.! !

"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!

AccountTransaction class
	instanceVariableNames: ''!

!classDefinition: 'AccountTransaction class' category: #'Portfolio-Solucion' stamp: 'cmmmmm 11/4/2019 18:55:29'!
AccountTransaction class
	instanceVariableNames: ''!
!AccountTransaction class methodsFor: 'instance creation' stamp: 'NR 10/21/2019 18:54:27'!
                register: aValue on: account

	| transaction |
	
	transaction := self for: aValue.
	account register: transaction.
		
	^ transaction! !

AccountTransaction subclass: #Deposit
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classDefinition: #Deposit category: #'Portfolio-Solucion' stamp: 'cmmmmm 11/4/2019 18:55:29'!
AccountTransaction subclass: #Deposit
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!
!Deposit methodsFor: 'initialization' stamp: 'HernanWilkinson 7/13/2011 18:45'!
                             initializeFor: aValue

	value := aValue ! !
!Deposit methodsFor: 'value' stamp: 'cmmmm 10/17/2019 19:27:56'!
                   updateBalance: aBalance

	^ aBalance + value! !
!Deposit methodsFor: 'value' stamp: 'cmmmm 10/17/2019 18:42:54'!
               valorParaBalance

	^ value! !
!Deposit methodsFor: 'value' stamp: 'HernanWilkinson 7/13/2011 18:38'!
                           value

	^ value! !
!Deposit methodsFor: 'balance' stamp: 'HAW 5/25/2019 11:25:02'!
             affectBalance: aBalance

	^aBalance + value ! !
!Deposit methodsFor: 'report' stamp: 'LS 10/28/2019 17:00:40'!
                 addToReport: aReport
	^aReport addDeposit: self.! !
!Deposit methodsFor: 'transferNet' stamp: 'LS 10/28/2019 16:47:37'!
        doTransferNet: aTransFernet
	^aTransFernet countDeposit: self.! !

"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!

Deposit class
	instanceVariableNames: ''!

!classDefinition: 'Deposit class' category: #'Portfolio-Solucion' stamp: 'cmmmmm 11/4/2019 18:55:29'!
Deposit class
	instanceVariableNames: ''!
!Deposit class methodsFor: 'instance creation' stamp: 'HernanWilkinson 7/13/2011 18:38'!
              for: aValue

	^ self new initializeFor: aValue ! !

AccountTransaction subclass: #TransferDeposit
	instanceVariableNames: 'transference'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classDefinition: #TransferDeposit category: #'Portfolio-Solucion' stamp: 'cmmmmm 11/4/2019 18:55:29'!
AccountTransaction subclass: #TransferDeposit
	instanceVariableNames: 'transference'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!
!TransferDeposit methodsFor: 'report' stamp: 'LS 10/28/2019 17:00:59'!
                     addToReport: aReport
	^aReport addTransferDeposit: self.! !
!TransferDeposit methodsFor: 'initialization' stamp: 'LS 10/22/2019 16:58:58'!
                     initializeFor: aTransfer

	transference := aTransfer ! !
!TransferDeposit methodsFor: 'value' stamp: 'LS 10/22/2019 17:01:37'!
 updateBalance: aBalance

	^ aBalance + self value! !
!TransferDeposit methodsFor: 'value' stamp: 'LS 10/22/2019 17:04:18'!
     valorParaBalance

	^ self value! !
!TransferDeposit methodsFor: 'value' stamp: 'LS 10/22/2019 16:59:14'!
                       value

	^ transference value.! !
!TransferDeposit methodsFor: 'balance' stamp: 'LS 10/22/2019 17:02:14'!
                       affectBalance: aBalance

	^aBalance + self value ! !
!TransferDeposit methodsFor: 'tranferNet' stamp: 'LS 10/28/2019 16:47:41'!
doTransferNet: aTransFernet
	^aTransFernet countTransferDeposit: self.! !

"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!

TransferDeposit class
	instanceVariableNames: ''!

!classDefinition: 'TransferDeposit class' category: #'Portfolio-Solucion' stamp: 'cmmmmm 11/4/2019 18:55:29'!
TransferDeposit class
	instanceVariableNames: ''!
!TransferDeposit class methodsFor: 'as yet unclassified' stamp: 'cmmmm 10/21/2019 21:49:03'!
          for: aValue

	^ self new initializeFor: aValue ! !

AccountTransaction subclass: #TransferWithdraw
	instanceVariableNames: 'transference'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classDefinition: #TransferWithdraw category: #'Portfolio-Solucion' stamp: 'cmmmmm 11/4/2019 18:55:29'!
AccountTransaction subclass: #TransferWithdraw
	instanceVariableNames: 'transference'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!
!TransferWithdraw methodsFor: 'report' stamp: 'LS 10/28/2019 17:01:17'!
                 addToReport: aReport
	^aReport addTransferWithdraw: self.! !
!TransferWithdraw methodsFor: 'value' stamp: 'LS 10/22/2019 17:04:40'!
                            updateBalance: aBalance

	^ aBalance - self value! !
!TransferWithdraw methodsFor: 'value' stamp: 'LS 10/22/2019 17:04:11'!
    valorParaBalance
	^ self value negated ! !
!TransferWithdraw methodsFor: 'value' stamp: 'LS 10/22/2019 17:03:46'!
              value

	^ transference value! !
!TransferWithdraw methodsFor: 'balance' stamp: 'LS 10/22/2019 17:05:03'!
                       affectBalance: aBalance

	^aBalance - self value! !
!TransferWithdraw methodsFor: 'initialization' stamp: 'LS 10/22/2019 17:00:25'!
                            initializeFor: aTransfer

	transference := aTransfer ! !
!TransferWithdraw methodsFor: 'tranferNet' stamp: 'LS 10/28/2019 16:47:46'!
                           doTransferNet: aTransFernet
	^aTransFernet countTransferWithdraw: self.! !

"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!

TransferWithdraw class
	instanceVariableNames: ''!

!classDefinition: 'TransferWithdraw class' category: #'Portfolio-Solucion' stamp: 'cmmmmm 11/4/2019 18:55:29'!
TransferWithdraw class
	instanceVariableNames: ''!
!TransferWithdraw class methodsFor: 'as yet unclassified' stamp: 'cmmmm 10/21/2019 21:49:40'!
     for: aValue

	^ self new initializeFor: aValue ! !

AccountTransaction subclass: #Withdraw
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classDefinition: #Withdraw category: #'Portfolio-Solucion' stamp: 'cmmmmm 11/4/2019 18:55:29'!
AccountTransaction subclass: #Withdraw
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!
!Withdraw methodsFor: 'initialization' stamp: 'HernanWilkinson 7/13/2011 18:46'!
              initializeFor: aValue

	value := aValue ! !
!Withdraw methodsFor: 'value' stamp: 'cmmmm 10/17/2019 19:28:10'!
                  updateBalance: aBalance

	^ aBalance - value! !
!Withdraw methodsFor: 'value' stamp: 'cmmmm 10/17/2019 18:42:47'!
              valorParaBalance
	^ value negated ! !
!Withdraw methodsFor: 'value' stamp: 'HernanWilkinson 7/13/2011 18:33'!
                  value

	^ value! !
!Withdraw methodsFor: 'balance' stamp: 'HAW 5/25/2019 11:25:15'!
            affectBalance: aBalance

	^aBalance - value! !
!Withdraw methodsFor: 'report' stamp: 'LS 10/28/2019 17:01:30'!
                 addToReport: aReport
	^aReport addWithdraw: self.! !
!Withdraw methodsFor: 'tranferNet' stamp: 'LS 10/28/2019 16:47:52'!
       doTransferNet: aTransFernet
	^aTransFernet countWithdraw: self.! !

"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!

Withdraw class
	instanceVariableNames: ''!

!classDefinition: 'Withdraw class' category: #'Portfolio-Solucion' stamp: 'cmmmmm 11/4/2019 18:55:29'!
Withdraw class
	instanceVariableNames: ''!
!Withdraw class methodsFor: 'instance creation' stamp: 'HernanWilkinson 7/13/2011 18:33'!
         for: aValue

	^ self new initializeFor: aValue ! !

Object subclass: #Report
	instanceVariableNames: 'account stream'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classDefinition: #Report category: #'Portfolio-Solucion' stamp: 'cmmmmm 11/4/2019 18:55:30'!
Object subclass: #Report
	instanceVariableNames: 'account stream'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!
!Report methodsFor: 'report' stamp: 'LS 10/28/2019 17:28:49'!
             addDeposit: aDeposit

	^stream := stream, 'Deposito por ', aDeposit value asString, '. '.! !
!Report methodsFor: 'report' stamp: 'LS 10/28/2019 17:29:06'!
     addTransferDeposit: aTransferDeposit

	^stream := stream, 'Entrada por Transferencia de ', aTransferDeposit value asString, '. '.! !
!Report methodsFor: 'report' stamp: 'LS 10/28/2019 17:29:10'!
                             addTransferWithdraw: aTransferWithdraw

	^stream := stream, 'Salida por Transferencia de ', aTransferWithdraw value asString, '. '.! !
!Report methodsFor: 'report' stamp: 'LS 10/28/2019 17:29:14'!
                           addWithdraw: aWithdraw

	^stream := stream, 'Extraccion por ', aWithdraw value asString, '. '.! !
!Report methodsFor: 'report' stamp: 'LS 10/28/2019 17:18:11'!
makeReport

	account reportOperations: self.
	stream := stream,'Balance = ', account balance asString.
	^stream! !
!Report methodsFor: 'initialization' stamp: 'LS 10/28/2019 16:55:21'!
       initializeWith: anAccount

	stream _ String new.
	account _ anAccount.! !

"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!

Report class
	instanceVariableNames: ''!

!classDefinition: 'Report class' category: #'Portfolio-Solucion' stamp: 'cmmmmm 11/4/2019 18:55:30'!
Report class
	instanceVariableNames: ''!
!Report class methodsFor: 'class initialization' stamp: 'LS 10/28/2019 14:16:31'!
                with: anAccount

	^self new initializeWith: anAccount.! !

Object subclass: #TransferNet
	instanceVariableNames: 'account net'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classDefinition: #TransferNet category: #'Portfolio-Solucion' stamp: 'cmmmmm 11/4/2019 18:55:30'!
Object subclass: #TransferNet
	instanceVariableNames: 'account net'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!
!TransferNet methodsFor: 'initialize' stamp: 'LS 10/28/2019 16:51:38'!
                    initializeWith: anAccount

	net := 0.
	account := anAccount.! !
!TransferNet methodsFor: 'counts dispatch' stamp: 'LS 10/28/2019 16:31:31'!
                    countDeposit: aDeposit

	^0.
	! !
!TransferNet methodsFor: 'counts dispatch' stamp: 'LS 10/28/2019 16:32:05'!
                  countTransferDeposit: aDeposit

	^net := net + aDeposit value.
	! !
!TransferNet methodsFor: 'counts dispatch' stamp: 'LS 10/28/2019 16:32:26'!
                countTransferWithdraw: aWithdraw

	^net := net - aWithdraw value.
	! !
!TransferNet methodsFor: 'counts dispatch' stamp: 'LS 10/28/2019 16:31:20'!
             countWithdraw: aWithdraw

	^0.
	! !
!TransferNet methodsFor: 'printing' stamp: 'LS 10/28/2019 16:53:41'!
                       printTransferNet
	
	account transferNet: self.
	^net! !

"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!

TransferNet class
	instanceVariableNames: ''!

!classDefinition: 'TransferNet class' category: #'Portfolio-Solucion' stamp: 'cmmmmm 11/4/2019 18:55:30'!
TransferNet class
	instanceVariableNames: ''!
!TransferNet class methodsFor: 'class initialization' stamp: 'LS 10/28/2019 16:22:04'!
              with: anAccount
	^self new initializeWith: anAccount.! !

Object subclass: #Transference
	instanceVariableNames: 'value transferDeposit transferWithdraw'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classDefinition: #Transference category: #'Portfolio-Solucion' stamp: 'cmmmmm 11/4/2019 18:55:30'!
Object subclass: #Transference
	instanceVariableNames: 'value transferDeposit transferWithdraw'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!
!Transference methodsFor: 'initialization' stamp: 'cmmmm 10/21/2019 21:47:06'!
                    initializeFrom: anAccountSource to: anAccountDestiny of: anAmount 

	transferDeposit := TransferDeposit register: anAmount on: anAccountDestiny. 
	transferWithdraw := TransferWithdraw register: anAmount on: anAccountSource .
	value  := anAmount.! !
!Transference methodsFor: 'value' stamp: 'cmmmm 10/21/2019 19:52:25'!
 value

	^value! !

"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!

Transference class
	instanceVariableNames: ''!

!classDefinition: 'Transference class' category: #'Portfolio-Solucion' stamp: 'cmmmmm 11/4/2019 18:55:30'!
Transference class
	instanceVariableNames: ''!
!Transference class methodsFor: 'initialization' stamp: 'LS 10/22/2019 17:10:05'!
                      from: anAccountSource to: anAccountDestiny of: anAmount 
	self assertAmountPositive: anAmount.
	^Transference new initializeFrom: anAccountSource to: anAccountDestiny of: anAmount.! !
!Transference class methodsFor: 'initialization' stamp: 'cmmmm 10/21/2019 20:38:07'!
                   register: aValue from: anAccountSource to: anAccountDestiny

	| transaction |
	
	transaction := self from: anAccountSource to: anAccountDestiny of: aValue. 
	anAccountSource register: transaction.
	anAccountDestiny register: transaction.
		
	^ transaction! !
!Transference class methodsFor: 'error messages' stamp: 'LS 10/22/2019 17:18:49'!
           cannotTransferNegativeAmount
	^'Cannot transfer negative amount'! !
!Transference class methodsFor: 'assertions' stamp: 'LS 10/22/2019 17:21:04'!
              assertAmountPositive: anAmount
	anAmount <1 ifTrue: [self error: Transference cannotTransferNegativeAmount].! !

----End fileIn of /Users/cmurga/Documents/Facultad/ejerciciosIS1/portFolio/Portfolio-Solucion.st----!
!CashierTest methodsFor: 'as yet unclassified' stamp: 'cmmmmm 11/4/2019 18:56:21' prior: 50332209!
      test02CheckoutACartWith1ElementIsCorrect

	| aCashier aCatalog aCart |
	
	aCatalog := Dictionary new.
	aCashier := Cashier with: aCatalog.
	
	aCart := Cart acceptingItemsOf: (Array with: 'validBook').
	
	aCart add: 123123123123.
	
	self assert: 100 equals: (aCashier checkOut: aCart) .	

		
		 ! !

!testRun: #CashierTest #test02CheckoutACartWith1ElementIsCorrect stamp: 'cmmmmm 11/4/2019 18:56:46'!
ERROR!
!CashierTest methodsFor: 'as yet unclassified' stamp: 'cmmmmm 11/4/2019 18:57:42' prior: 50333550!
      test02CheckoutACartWith1ElementIsCorrect

	| aCashier aCatalog aCart |
	
	aCatalog := Dictionary new.
	aCashier := Cashier with: aCatalog.
	
	aCart := Cart acceptingItemsOf: (Array with: 'validBook').
	
	aCart add: 'validBook'.
	
	self assert: 100 equals: (aCashier checkOut: aCart) .	

		
		 ! !

!testRun: #CashierTest #test02CheckoutACartWith1ElementIsCorrect stamp: 'cmmmmm 11/4/2019 18:57:43'!
ERROR!

!classDefinition: #Cashier category: #TusLibros stamp: 'cmmmmm 11/4/2019 18:58:55'!
Object subclass: #Cashier
	instanceVariableNames: 'itemInCart catalog'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

Object subclass: #Cashier
	instanceVariableNames: 'catalog'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #Cashier category: #TusLibros stamp: 'cmmmmm 11/4/2019 19:00:09'!
Object subclass: #Cashier
	instanceVariableNames: 'catalog'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!testRun: #CashierTest #test02CheckoutACartWith1ElementIsCorrect stamp: 'cmmmmm 11/4/2019 19:00:39'!
ERROR!
!Cashier methodsFor: 'as yet unclassified' stamp: 'cmmmmm 11/4/2019 19:10:27' prior: 50332152!
  checkOut: aCart 
	
	"self assert cada item del cart esta en el catalogo"
	aCart isEmpty ifTrue: [self error: Cashier cartCanNotBeEmpty.]
	ifFalse: [ ^ aCart subtotal ]! !

!testRun: #CashierTest #test02CheckoutACartWith1ElementIsCorrect stamp: 'cmmmmm 11/4/2019 19:10:34'!
ERROR!
!Cart methodsFor: 'as yet unclassified' stamp: 'cmmmmm 11/4/2019 19:10:42'!
                            subtotal
	self shouldBeImplemented.! !
!Cart methodsFor: 'as yet unclassified' stamp: 'cmmmmm 11/4/2019 19:13:39' prior: 50333615!
                             subtotal
	| sum |
	sum _ 0.
	catalog do: [:anItem | sum _ sum + anItem ]. 
	^sum.! !
!Cart methodsFor: 'as yet unclassified' stamp: 'cmmmmm 11/4/2019 19:13:41' prior: 50333620!
               subtotal
	| sum |

	sum _ 0.
	catalog do: [:anItem | sum _ sum + anItem ]. 
	^sum.! !

!testRun: #CashierTest #test02CheckoutACartWith1ElementIsCorrect stamp: 'cmmmmm 11/4/2019 19:13:45'!
ERROR!
!CashierTest methodsFor: 'as yet unclassified' stamp: 'cmmmmm 11/4/2019 19:15:25' prior: 50333566!
                          test02CheckoutACartWith1ElementIsCorrect

	| aCashier aCatalog aCart |
	
	aCatalog := Dictionary new.
	aCashier := Cashier with: aCatalog.
	
	aCart := Cart acceptingItemsOf: (Dictionary new add:'validBook'->4).
	
	aCart add: 'validBook'.
	
	self assert: 100 equals: (aCashier checkOut: aCart) .	

		
		 ! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'cmmmmm 11/4/2019 19:15:30' prior: 50333636!
          test02CheckoutACartWith1ElementIsCorrect

	| aCashier aCatalog aCart |
	
	aCatalog := Dictionary new.
	aCashier := Cashier with: aCatalog.
	
	aCart := Cart acceptingItemsOf: (Dictionary new add:'validBook'->100).
	
	aCart add: 'validBook'.
	
	self assert: 100 equals: (aCashier checkOut: aCart) .	

		
		 ! !

!testRun: #CashierTest #test02CheckoutACartWith1ElementIsCorrect stamp: 'cmmmmm 11/4/2019 19:15:36'!
ERROR!
!CashierTest methodsFor: 'as yet unclassified' stamp: 'cmmmmm 11/4/2019 19:17:37' prior: 50333649!
                           test02CheckoutACartWith1ElementIsCorrect

	| aCashier aCatalog aCart |
	
	aCatalog := Dictionary new.
	aCashier := Cashier with: aCatalog.
	
	aCart := Cart acceptingItemsOf: (aCatalog add:'validBook'->100).
	
	aCart add: 'validBook'.
	
	self assert: 100 equals: (aCashier checkOut: aCart) .	

		
		 ! !

!testRun: #CashierTest #test02CheckoutACartWith1ElementIsCorrect stamp: 'cmmmmm 11/4/2019 19:18:04'!
ERROR!

!testRun: #CashierTest #test02CheckoutACartWith1ElementIsCorrect stamp: 'cmmmmm 11/4/2019 19:18:27'!
ERROR!
!CashierTest methodsFor: 'as yet unclassified' stamp: 'cmmmmm 11/4/2019 19:18:55' prior: 50333666!
                    test02CheckoutACartWith1ElementIsCorrect

	| aCashier aCatalog aCart |
	
	aCatalog := Dictionary new.
	aCashier := Cashier new.
	
	aCart := Cart acceptingItemsOf: (aCatalog add:'validBook'->100).
	
	aCart add: 'validBook'.
	
	self assert: 100 equals: (aCashier checkOut: aCart) .	

		
		 ! !

!testRun: #CashierTest #test02CheckoutACartWith1ElementIsCorrect stamp: 'cmmmmm 11/4/2019 19:20:10'!
ERROR!
!CashierTest methodsFor: 'as yet unclassified' stamp: 'cmmmmm 11/4/2019 19:21:27' prior: 50333686!
            test02CheckoutACartWith1ElementIsCorrect

	| aCashier aCatalog aCart |
	
	aCatalog := Dictionary new.
	aCashier := Cashier new.
	
	aCatalog add:'validBook'->100.
	aCart := Cart acceptingItemsOf: aCatalog.
	
	aCart add: 'validBook'.
	
	self assert: 100 equals: (aCashier checkOut: aCart) .	

		
		 ! !
!Cart methodsFor: 'assertions' stamp: 'cmmmmm 11/4/2019 19:24:33' prior: 50332077!
assertIsValidItem: anItem

	(catalog includesKey: anItem) ifFalse: [ self error: self invalidItemErrorMessage ]! !

!testRun: #CashierTest #test02CheckoutACartWith1ElementIsCorrect stamp: 'cmmmmm 11/4/2019 19:24:58'!
PASSED!

!testRun: #CashierTest #test01NewCashierWith stamp: 'cmmmmm 11/4/2019 19:24:58'!
PASSED!

!testRun: #CashierTest #test02CheckoutACartWith1ElementIsCorrect stamp: 'cmmmmm 11/4/2019 19:24:58'!
PASSED!
!Cashier class methodsFor: 'instance creation' stamp: 'cmmmmm 11/4/2019 19:26:46' prior: 50332168!
                    with: aSalesBook 
	
	^self new initializeWith: aSalesBook ! !

!classDefinition: #Cashier category: #TusLibros stamp: 'cmmmmm 11/4/2019 19:27:15'!
Object subclass: #Cashier
	instanceVariableNames: 'catalog salesBook'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!Cashier methodsFor: 'initialization' stamp: 'cmmmmm 11/4/2019 19:27:11' prior: 50332144!
       initializeWith: aSalesBook
	
	salesBook := aSalesBook.! !

Object subclass: #Cashier
	instanceVariableNames: 'catalog salesBook'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #Cashier category: #TusLibros stamp: 'cmmmmm 11/4/2019 19:27:23'!
Object subclass: #Cashier
	instanceVariableNames: 'catalog salesBook'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

Object subclass: #Cashier
	instanceVariableNames: 'salesBook'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #Cashier category: #TusLibros stamp: 'cmmmmm 11/4/2019 19:27:43'!
Object subclass: #Cashier
	instanceVariableNames: 'salesBook'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!CashierTest methodsFor: 'as yet unclassified' stamp: 'cmmmmm 11/4/2019 19:28:13' prior: 50333702!
                       test02CheckoutACartWith1ElementIsCorrect

	| aCashier aCatalog aCart |
	
	aCatalog := Dictionary new.
	aCashier := Cashier with orderedCollection new.
	
	aCatalog add:'validBook'->100.
	aCart := Cart acceptingItemsOf: aCatalog.
	
	aCart add: 'validBook'.
	
	self assert: 100 equals: (aCashier checkOut: aCart) .	

		
		 ! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'cmmmmm 11/4/2019 19:28:22' prior: 50333771!
                         test02CheckoutACartWith1ElementIsCorrect

	| aCashier aCatalog aCart |
	
	aCatalog := Dictionary new.
	aCashier := Cashier with: OrderedCollection new.
	
	aCatalog add:'validBook'->100.
	aCart := Cart acceptingItemsOf: aCatalog.
	
	aCart add: 'validBook'.
	
	self assert: 100 equals: (aCashier checkOut: aCart) .	

		
		 ! !

!testRun: #CashierTest #test02CheckoutACartWith1ElementIsCorrect stamp: 'cmmmmm 11/4/2019 19:29:52'!
PASSED!

!testRun: #CashierTest #test01NewCashierWith stamp: 'cmmmmm 11/4/2019 19:29:52'!
PASSED!

!testRun: #CashierTest #test02CheckoutACartWith1ElementIsCorrect stamp: 'cmmmmm 11/4/2019 19:29:52'!
PASSED!

!testRun: #CashierTest #test02CheckoutACartWith1ElementIsCorrect stamp: 'cmmmmm 11/4/2019 19:29:54'!
PASSED!

!testRun: #CashierTest #test01NewCashierWith stamp: 'cmmmmm 11/4/2019 19:29:54'!
PASSED!

!testRun: #CashierTest #test02CheckoutACartWith1ElementIsCorrect stamp: 'cmmmmm 11/4/2019 19:29:54'!
PASSED!
!CashierTest methodsFor: 'as yet unclassified' stamp: 'cmmmmm 11/4/2019 19:30:57'!
                            test03CheckoutACartWithSeveralElementGivesCorrectSubtotal

	| aCashier aCatalog aCart |
	
	aCatalog := Dictionary new.
	aCashier := Cashier with: OrderedCollection new.
	
	aCatalog add:'validBook'->100.
	aCart := Cart acceptingItemsOf: aCatalog.
	
	aCart add: 'validBook'.
	aCart add: 'validBook'.
	aCart add: 'validBook'.
	
	self assert: 100 equals: (aCashier checkOut: aCart) .	

		
		 ! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'cmmmmm 11/4/2019 19:32:05' prior: 50333818!
                     test03CheckoutACartWithSeveralElementGivesCorrectSubtotal

	| aCashier aCatalog aCart |
	
	aCatalog := Dictionary new.
	aCashier := Cashier with: OrderedCollection new.
	
	aCatalog add:'validBook'->100; add:'validBook2'->50.
	aCart := Cart acceptingItemsOf: aCatalog.
	
	aCart add: 'validBook'.
	aCart add: 'validBook2'.
	
	self assert: 100 equals: (aCashier checkOut: aCart) .	

		
		 ! !

!testRun: #CashierTest #test03CheckoutACartWithSeveralElementGivesCorrectSubtotal stamp: 'cmmmmm 11/4/2019 19:32:07'!
FAILURE!
!Cashier methodsFor: 'as yet unclassified' stamp: 'cmmmmm 11/4/2019 19:32:30' prior: 50333603!
                           checkOut: aCart 
	
	aCart isEmpty ifTrue: [self error: Cashier cartCanNotBeEmpty.]
	ifFalse: [ ^ aCart subtotal ]! !

!testRun: #CashierTest #test03CheckoutACartWithSeveralElementGivesCorrectSubtotal stamp: 'cmmmmm 11/4/2019 19:32:44'!
FAILURE!
!CashierTest methodsFor: 'as yet unclassified' stamp: 'cmmmmm 11/4/2019 19:32:52' prior: 50333834!
        test03CheckoutACartWithSeveralElementGivesCorrectSubtotal

	| aCashier aCatalog aCart |
	
	aCatalog := Dictionary new.
	aCashier := Cashier with: OrderedCollection new.
	
	aCatalog add:'validBook'->100; add:'validBook2'->50.
	aCart := Cart acceptingItemsOf: aCatalog.
	
	aCart add: 'validBook'.
	aCart add: 'validBook2'.
	
	self assert: 150 equals: (aCashier checkOut: aCart) .	

		
		 ! !

!testRun: #CashierTest #test03CheckoutACartWithSeveralElementGivesCorrectSubtotal stamp: 'cmmmmm 11/4/2019 19:32:55'!
PASSED!

!testRun: #CashierTest #test01NewCashierWith stamp: 'cmmmmm 11/4/2019 19:32:55'!
PASSED!

!testRun: #CashierTest #test02CheckoutACartWith1ElementIsCorrect stamp: 'cmmmmm 11/4/2019 19:32:55'!
PASSED!

!testRun: #CashierTest #test03CheckoutACartWithSeveralElementGivesCorrectSubtotal stamp: 'cmmmmm 11/4/2019 19:32:55'!
PASSED!

!classDefinition: #Card category: #Unknown stamp: 'cmmmmm 11/4/2019 19:41:04'!
Object subclass: #Card
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Unknown'!
!CashierTest methodsFor: 'as yet unclassified' stamp: 'cmmmmm 11/4/2019 19:41:08'!
                           test04CannotCheckoutACartWithAnInvalidCreditCard

	| aCashier aCatalog aCart aCard aDate|
	
	aCatalog := Dictionary new.
	aCashier := Cashier with: OrderedCollection new.
	aCard := Card withNumber: 123123123 expirationDate: aDate owner: 'San Martin'.
	
	aCatalog add:'validBook'->100.
	aCart := Cart acceptingItemsOf: aCatalog.
	
	aCart add: 'validBook'.
	
	self assert: 150 equals: (aCashier checkOut: aCart) .	

		
		 ! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'cmmmmm 11/4/2019 19:42:01' prior: 50333901!
                     test04CannotCheckoutACartWithAnInvalidCreditCard

	| aCashier aCatalog aCart aCard aDate|
	
	aDate := GregorianMonthOfYear current .
	aCatalog := Dictionary new.
	aCashier := Cashier with: OrderedCollection new.
	aCard := Card withNumber: 123123123 expirationDate: aDate owner: 'San Martin'.
	
	aCatalog add:'validBook'->100.
	aCart := Cart acceptingItemsOf: aCatalog.
	
	aCart add: 'validBook'.
	
	self assert: 150 equals: (aCashier checkOut: aCart) .	

		
		 ! !

Card!

Card!

Object subclass: #Card
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #Card category: #TusLibros stamp: 'cmmmmm 11/4/2019 19:43:49'!
Object subclass: #Card
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

Object subclass: #CreditCard
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #CreditCard category: #TusLibros stamp: 'cmmmmm 11/4/2019 19:44:50'!
Object subclass: #CreditCard
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!CashierTest methodsFor: 'as yet unclassified' stamp: 'cmmmmm 11/4/2019 19:45:23' prior: 50333918!
      test04CannotCheckoutACartWithAnInvalidCreditCard

	| aCashier aCatalog aCart aCard aDate|
	
	aDate := GregorianMonthOfYear current .
	aCatalog := Dictionary new.
	aCashier := Cashier with: OrderedCollection new.
	aCard := CreditCard withNumber: 123123123 expirationDate: aDate owner: 'San Martin'.
	
	aCatalog add:'validBook'->100.
	aCart := Cart acceptingItemsOf: aCatalog.
	
	aCart add: 'validBook'.
	
	self assert: 150 equals: (aCashier checkOut: aCart) .	

		
		 ! !

!classRemoval: #Card stamp: 'cmmmmm 11/4/2019 19:46:03'!
Object subclass: #Card
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

TestCase subclass: #CreditCardTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #CreditCardTest category: #TusLibros stamp: 'cmmmmm 11/4/2019 19:46:23'!
TestCase subclass: #CreditCardTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!CreditCardTest methodsFor: 'nil' stamp: 'cmmmmm 11/4/2019 19:46:42'!
            test01CannotCreateCardWithInvalidNumber! !
!CreditCardTest methodsFor: 'as yet unclassified' stamp: 'cmmmmm 11/4/2019 19:51:19' prior: 50333991!
               test01CannotCreateCardWithInvalidNumber
	| aPerson anExpirationDate anId |
	
	aPerson := 'San Martin'.
	anExpirationDate := GregorianMonthOfYear current.
	anId := 0.
	
self should: [  CreditCard withNumber: anId expirationDate: anExpirationDate owner: aPerson ]
	raise: Error - MessageNotUnderstood
	withExceptionDo: [ :anError |
		self assert: anError messageText = CreditCard invalidNumber.
			]! !

!testRun: #CreditCardTest #test01CannotCreateCardWithInvalidNumber stamp: 'cmmmmm 11/4/2019 19:51:24'!
ERROR!
!CreditCard class methodsFor: 'instance creation' stamp: 'cmmmmm 11/4/2019 19:51:38'!
          withNumber: aSmallInteger expirationDate: aGregorianMonthOfYear owner: aString 
	"DO NOT FORGET TO RENAME COLLABORATORS AND REMOVE THIS COMMENT!!!!"
	self shouldBeImplemented.
	^self new initializeWithNumber: aSmallInteger expirationDate: aGregorianMonthOfYear owner: aString ! !
!CreditCard class methodsFor: 'instance creation' stamp: 'cmmmmm 11/4/2019 19:52:22' prior: 50334015!
  withNumber: anId expirationDate: anExpirationDate owner: aPerson 
	"DO NOT FORGET TO RENAME COLLABORATORS AND REMOVE THIS COMMENT!!!!"
	
	^self new initializeWithNumber: anId expirationDate: anExpirationDate owner: aPerson ! !

!testRun: #CreditCardTest #test01CannotCreateCardWithInvalidNumber stamp: 'cmmmmm 11/4/2019 19:52:25'!
ERROR!

!classDefinition: #CreditCard category: #TusLibros stamp: 'cmmmmm 11/4/2019 19:52:38'!
Object subclass: #CreditCard
	instanceVariableNames: 'id'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #CreditCard category: #TusLibros stamp: 'cmmmmm 11/4/2019 19:52:38'!
Object subclass: #CreditCard
	instanceVariableNames: 'id expirationDate'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #CreditCard category: #TusLibros stamp: 'cmmmmm 11/4/2019 19:52:38'!
Object subclass: #CreditCard
	instanceVariableNames: 'id expirationDate person'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!CreditCard methodsFor: 'initialization' stamp: 'cmmmmm 11/4/2019 19:52:38'!
                    initializeWithNumber: anId expirationDate: anExpirationDate owner: aPerson 
	self shouldBeImplemented.
	id := anId.
	expirationDate := anExpirationDate.
	person := aPerson.! !
!CreditCard methodsFor: 'initialization' stamp: 'cmmmmm 11/4/2019 19:52:42' prior: 50334062!
                   initializeWithNumber: anId expirationDate: anExpirationDate owner: aPerson 
	
	id := anId.
	expirationDate := anExpirationDate.
	person := aPerson.! !

!testRun: #CreditCardTest #test01CannotCreateCardWithInvalidNumber stamp: 'cmmmmm 11/4/2019 19:52:52'!
FAILURE!
!CreditCard class methodsFor: 'instance creation' stamp: 'cmmmmm 11/4/2019 19:53:38' prior: 50334027!
                  withNumber: anId expirationDate: anExpirationDate owner: aPerson 
	
	^self new initializeWithNumber: anId expirationDate: anExpirationDate owner: aPerson ! !
!CreditCard methodsFor: 'initialization' stamp: 'cmmmmm 11/4/2019 19:55:44' prior: 50334071!
     initializeWithNumber: anId expirationDate: anExpirationDate owner: aPerson 
	
	anId > 999999999999999 ifFalse: [self error: CreditCard invalidNumber].
	id := anId.
	expirationDate := anExpirationDate.
	person := aPerson.! !

!testRun: #CreditCardTest #test01CannotCreateCardWithInvalidNumber stamp: 'cmmmmm 11/4/2019 19:55:49'!
ERROR!
!CreditCard class methodsFor: 'Error Handling' stamp: 'cmmmmm 11/4/2019 19:56:12'!
                              invalidNumber
	self shouldBeImplemented.! !
!CreditCard class methodsFor: 'Error Handling' stamp: 'cmmmmm 11/4/2019 19:56:26' prior: 50334105!
                 invalidNumber
	^'Invalid card Number'.! !

!testRun: #CreditCardTest #test01CannotCreateCardWithInvalidNumber stamp: 'cmmmmm 11/4/2019 19:56:27'!
PASSED!

!testRun: #CreditCardTest #test01CannotCreateCardWithInvalidNumber stamp: 'cmmmmm 11/4/2019 19:56:27'!
PASSED!
!CreditCardTest methodsFor: 'as yet unclassified' stamp: 'cmmmmm 11/4/2019 20:00:41'!
test02CannotCreateCardWithInvalidGreaterNumber
	| aPerson anExpirationDate anId |
	
	aPerson := 'San Martin'.
	anExpirationDate := GregorianMonthOfYear current.
	anId := 10 raisedToInteger: 17.
	
self should: [  CreditCard withNumber: anId expirationDate: anExpirationDate owner: aPerson ]
	raise: Error - MessageNotUnderstood
	withExceptionDo: [ :anError |
		self assert: anError messageText = CreditCard invalidNumber.
			]! !
!CreditCardTest methodsFor: 'as yet unclassified' stamp: 'cmmmmm 11/4/2019 20:00:55' prior: 50334121!
             test02CannotCreateCardWithInvalidGreaterNumber
	| aPerson anExpirationDate anId |
	
	aPerson := 'San Martin'.
	anExpirationDate := GregorianMonthOfYear current.
	anId := 10 raisedToInteger: 16.
	
self should: [  CreditCard withNumber: anId expirationDate: anExpirationDate owner: aPerson ]
	raise: Error - MessageNotUnderstood
	withExceptionDo: [ :anError |
		self assert: anError messageText = CreditCard invalidNumber.
			]! !

!testRun: #CreditCardTest #test02CannotCreateCardWithInvalidGreaterNumber stamp: 'cmmmmm 11/4/2019 20:01:05'!
FAILURE!
!CreditCard methodsFor: 'initialization' stamp: 'cmmmmm 11/4/2019 20:02:22' prior: 50334091!
                              initializeWithNumber: anId expirationDate: anExpirationDate owner: aPerson 
	
	anId > 999999999999999 ifFalse: [self error: CreditCard invalidNumber].
	(anId < 10 raisedToInteger: 16) ifFalse: [self error: CreditCard invalidNumber].
	id := anId.
	expirationDate := anExpirationDate.
	person := aPerson.! !

!testRun: #CreditCardTest #test02CannotCreateCardWithInvalidGreaterNumber stamp: 'cmmmmm 11/4/2019 20:02:24'!
ERROR!
!CreditCard methodsFor: 'initialization' stamp: 'cmmmmm 11/4/2019 20:02:40' prior: 50334159!
                           initializeWithNumber: anId expirationDate: anExpirationDate owner: aPerson 
	
	anId > 999999999999999 ifFalse: [self error: CreditCard invalidNumber].
	anId < (10 raisedToInteger: 16) ifFalse: [self error: CreditCard invalidNumber].
	id := anId.
	expirationDate := anExpirationDate.
	person := aPerson.! !

!testRun: #CreditCardTest #test02CannotCreateCardWithInvalidGreaterNumber stamp: 'cmmmmm 11/4/2019 20:02:41'!
PASSED!

!testRun: #CreditCardTest #test01CannotCreateCardWithInvalidNumber stamp: 'cmmmmm 11/4/2019 20:02:41'!
PASSED!

!testRun: #CreditCardTest #test02CannotCreateCardWithInvalidGreaterNumber stamp: 'cmmmmm 11/4/2019 20:02:41'!
PASSED!
!CreditCard methodsFor: 'initialization' stamp: 'cmmmmm 11/4/2019 20:04:32' prior: 50334176!
                   initializeWithNumber: anId expirationDate: anExpirationDate owner: aPerson 
	
	(anId between: (10 raisedToInteger: 15) and: (10 raisedToInteger: 16)) ifFalse: [self error: CreditCard invalidNumber].
	id := anId.
	expirationDate := anExpirationDate.
	person := aPerson.! !

!testRun: #CreditCardTest #test01CannotCreateCardWithInvalidNumber stamp: 'cmmmmm 11/4/2019 20:04:38'!
PASSED!

!testRun: #CreditCardTest #test02CannotCreateCardWithInvalidGreaterNumber stamp: 'cmmmmm 11/4/2019 20:04:38'!
FAILURE!

!testRun: #CreditCardTest #test02CannotCreateCardWithInvalidGreaterNumber stamp: 'cmmmmm 11/4/2019 20:04:38'!
FAILURE!
!CreditCard methodsFor: 'initialization' stamp: 'cmmmmm 11/4/2019 20:06:20' prior: 50334200!
                   initializeWithNumber: anId expirationDate: anExpirationDate owner: aPerson 
	
	(anId between: (10 raisedToInteger: 15) and: ((10 raisedToInteger: 16) +1)) ifFalse: [self error: CreditCard invalidNumber].
	id := anId.
	expirationDate := anExpirationDate.
	person := aPerson.! !

!testRun: #CreditCardTest #test02CannotCreateCardWithInvalidGreaterNumber stamp: 'cmmmmm 11/4/2019 20:06:23'!
FAILURE!
!CreditCard methodsFor: 'initialization' stamp: 'cmmmmm 11/4/2019 20:07:21' prior: 50334223!
                      initializeWithNumber: anId expirationDate: anExpirationDate owner: aPerson 
	
	(anId between: (10 raisedToInteger: 15) and: ((10 raisedToInteger: 16) -1)) ifFalse: [self error: CreditCard invalidNumber].
	id := anId.
	expirationDate := anExpirationDate.
	person := aPerson.! !

!testRun: #CreditCardTest #test02CannotCreateCardWithInvalidGreaterNumber stamp: 'cmmmmm 11/4/2019 20:07:24'!
PASSED!

!testRun: #CreditCardTest #test01CannotCreateCardWithInvalidNumber stamp: 'cmmmmm 11/4/2019 20:07:29'!
PASSED!

!testRun: #CreditCardTest #test02CannotCreateCardWithInvalidGreaterNumber stamp: 'cmmmmm 11/4/2019 20:07:29'!
PASSED!

GregorianMonthOfYear current!
!CreditCardTest methodsFor: 'as yet unclassified' stamp: 'cmmmmm 11/4/2019 20:09:18' prior: 50334138!
        test02CannotCreateCardWithInvalidGreaterNumber
	| aPerson anExpirationDate anId |
	
	aPerson := 'San Martin'.
	anExpirationDate := GregorianMonthOfYear current.
	anId := 10 raisedToInteger: 16.
	
self should: [  CreditCard withNumber: anId expirationDate: anExpirationDate owner: aPerson ]
	raise: Error - MessageNotUnderstood
	withExceptionDo: [ :anError |
		self assert: anError messageText = CreditCard invalidNumber.
			]! !
!CreditCardTest methodsFor: 'as yet unclassified' stamp: 'cmmmmm 11/4/2019 20:10:12'!
                             test03CannotCreateCardWithemptyOwner
	| aPerson anExpirationDate anId |
	
	aPerson := ''.
	anExpirationDate := GregorianMonthOfYear current.
	anId := 10 raisedToInteger: 16.
	
self should: [  CreditCard withNumber: anId expirationDate: anExpirationDate owner: aPerson ]
	raise: Error - MessageNotUnderstood
	withExceptionDo: [ :anError |
		self assert: anError messageText = CreditCard invalidOwner.
			]! !
!CreditCardTest methodsFor: 'as yet unclassified' stamp: 'cmmmmm 11/4/2019 20:10:32' prior: 50334280!
  test03CannotCreateCardWithemptyOwner
	| aPerson anExpirationDate anId |
	
	aPerson := ''.
	anExpirationDate := GregorianMonthOfYear current.
	anId := 10 raisedToInteger: 15.
	
self should: [  CreditCard withNumber: anId expirationDate: anExpirationDate owner: aPerson ]
	raise: Error - MessageNotUnderstood
	withExceptionDo: [ :anError |
		self assert: anError messageText = CreditCard invalidOwner.
			]! !

!testRun: #CreditCardTest #test03CannotCreateCardWithemptyOwner stamp: 'cmmmmm 11/4/2019 20:10:38'!
FAILURE!
!CreditCard methodsFor: 'initialization' stamp: 'cmmmmm 11/4/2019 20:11:25' prior: 50334239!
                             initializeWithNumber: anId expirationDate: anExpirationDate owner: aPerson 
	
	(anId between: (10 raisedToInteger: 15) and: ((10 raisedToInteger: 16) -1)) ifFalse: [self error: CreditCard invalidNumber].
	aPerson isEmpty ifTrue: [self error: CreditCard invalidOwner].
	id := anId.
	expirationDate := anExpirationDate.
	person := aPerson.! !

!testRun: #CreditCardTest #test03CannotCreateCardWithemptyOwner stamp: 'cmmmmm 11/4/2019 20:11:26'!
ERROR!
!CreditCard class methodsFor: 'as yet unclassified' stamp: 'cmmmmm 11/4/2019 20:11:44'!
       invalidOwner
	self shouldBeImplemented.! !
!CreditCard class methodsFor: 'as yet unclassified' stamp: 'cmmmmm 11/4/2019 20:12:01' prior: 50334333!
             invalidOwner
	^'InvalidOwner'.! !

!testRun: #CreditCardTest #test03CannotCreateCardWithemptyOwner stamp: 'cmmmmm 11/4/2019 20:12:02'!
PASSED!

!testRun: #CreditCardTest #test01CannotCreateCardWithInvalidNumber stamp: 'cmmmmm 11/4/2019 20:12:02'!
PASSED!

!testRun: #CreditCardTest #test02CannotCreateCardWithInvalidGreaterNumber stamp: 'cmmmmm 11/4/2019 20:12:02'!
PASSED!

!testRun: #CreditCardTest #test03CannotCreateCardWithemptyOwner stamp: 'cmmmmm 11/4/2019 20:12:02'!
PASSED!
!CreditCard methodsFor: 'initialization' stamp: 'cmmmmm 11/4/2019 20:14:23'!
                isValid

	(id between: (10 raisedToInteger: 15) and: ((10 raisedToInteger: 16) -1)) ifFalse: [self error: CreditCard invalidNumber].
	person isEmpty ifTrue: [self error: CreditCard invalidOwner].! !
!CreditCard methodsFor: 'initialization' stamp: 'cmmmmm 11/4/2019 20:14:34' prior: 50334356!
                            isValid

	(id between: (10 raisedToInteger: 15) and: ((10 raisedToInteger: 16) -1)) ifFalse: [self error: CreditCard invalidNumber].
	person isEmpty ifTrue: [self error: CreditCard invalidOwner].
	^true.! !
!CreditCard methodsFor: 'initialization' stamp: 'cmmmmm 11/4/2019 20:14:54' prior: 50334316!
                    initializeWithNumber: anId expirationDate: anExpirationDate owner: aPerson 
	
	id := anId.
	expirationDate := anExpirationDate.
	person := aPerson.
	self isValid.! !

!testRun: #CreditCardTest #test01CannotCreateCardWithInvalidNumber stamp: 'cmmmmm 11/4/2019 20:15:22'!
PASSED!

!testRun: #CreditCardTest #test02CannotCreateCardWithInvalidGreaterNumber stamp: 'cmmmmm 11/4/2019 20:15:22'!
PASSED!

!testRun: #CreditCardTest #test03CannotCreateCardWithemptyOwner stamp: 'cmmmmm 11/4/2019 20:15:22'!
PASSED!
!CashierTest methodsFor: 'as yet unclassified' stamp: 'cmmmmm 11/4/2019 20:17:53'!
                   test04CannotCheckoutACartWithAnExpiredCreditCard

	| aCashier aCatalog aCart aCard aDate|
	
	aDate := GregorianMonthOfYear current .
	aCatalog := Dictionary new.
	aCashier := Cashier with: OrderedCollection new.
	aCard := CreditCard withNumber: 123123123 expirationDate: aDate owner: 'San Martin'.
	
	aCatalog add:'validBook'->100.
	aCart := Cart acceptingItemsOf: aCatalog.
	
	aCart add: 'validBook'.
	
	self assert: 150 equals: (aCashier checkOut: aCart) .	

		
		 ! !

GregorianMonthOfYear!
!CashierTest methodsFor: 'as yet unclassified' stamp: 'cmmmmm 11/4/2019 20:21:26' prior: 50334395!
               test04CannotCheckoutACartWithAnExpiredCreditCard

	| aCashier aCatalog aCart aCard aDate anExpiredDate|
	
	anExpiredDate := GregorianMonthOfYear decemberOf: 2018.
	aCatalog := Dictionary new.
	aCashier := Cashier with: OrderedCollection new.
	aCard := CreditCard withNumber: (10 raisedToInteger: 15) expirationDate: anExpiredDate owner: 'San Martin'.
	
	aCatalog add:'validBook'->100.
	aCart := Cart acceptingItemsOf: aCatalog.
	
	aCart add: 'validBook'.
	
	self assert: 150 equals: (aCashier checkOut: aCart) .	

		
		 ! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'cmmmmm 11/4/2019 20:22:01' prior: 50334414!
                 test04CannotCheckoutACartWithAnExpiredCreditCard

	| aCashier aCatalog aCart aCard aDate anExpiredDate aCurrentDate|
	
	anExpiredDate := GregorianMonthOfYear decemberOf: 2018.
	aCurrentDate := GregorianMonthOfYear decemberOf: 2019.
	
	aCatalog := Dictionary new.
	aCashier := Cashier with: OrderedCollection new.
	aCard := CreditCard withNumber: (10 raisedToInteger: 15) expirationDate: anExpiredDate owner: 'San Martin'.
	
	aCatalog add:'validBook'->100.
	aCart := Cart acceptingItemsOf: aCatalog.
	
	aCart add: 'validBook'.
	
	self assert: 150 equals: (aCashier checkOut: aCart) .	

		
		 ! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'cmmmmm 11/4/2019 20:23:06' prior: 50334434!
          test04CannotCheckoutACartWithAnExpiredCreditCard

	| aCashier aCatalog aCart aCard aDate anExpiredDate aCurrentDate|
	
	anExpiredDate := GregorianMonthOfYear decemberOf: 2018.
	aCurrentDate := GregorianMonthOfYear decemberOf: 2019.
	
	aCatalog := Dictionary new.
	aCashier := Cashier with: OrderedCollection new.
	aCard := CreditCard withNumber: (10 raisedToInteger: 15) expirationDate: anExpiredDate owner: 'San Martin'.
	
	aCatalog add:'validBook'->100.
	aCart := Cart acceptingItemsOf: aCatalog.
	
	aCart add: 'validBook'.
	
	self assert: 150 equals: (aCashier checkOut: aCart) .	

	self should: [ aCashier checkOut: aCart onDate: aCurrentDate ]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [ :anError |
			self assert: anError messageText = Cashier cartCanNotBeEmpty.
			]
		
		 ! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'cmmmmm 11/4/2019 20:27:04' prior: 50334456!
                              test04CannotCheckoutACartWithAnExpiredCreditCard

	| aCashier aCatalog aCart aCard anExpiredDate aCurrentDate|
	
	anExpiredDate := GregorianMonthOfYear decemberOf: 2018.
	aCurrentDate := GregorianMonthOfYear decemberOf: 2019.
	
	aCatalog := Dictionary new.
	aCashier := Cashier with: OrderedCollection new onDate: aCurrentDate.
	aCard := CreditCard withNumber: (10 raisedToInteger: 15) expirationDate: anExpiredDate owner: 'San Martin'.
	
	aCatalog add:'validBook'->100.
	aCart := Cart acceptingItemsOf: aCatalog.
	
	aCart add: 'validBook'.
	
	self assert: 150 equals: (aCashier checkOut: aCart) .	

	self should: [ aCashier checkOut: aCart withCard: aCard ]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [ :anError |
			self assert: anError messageText = Cashier cartCanNotBeEmpty.
			]
		
		 ! !

!testRun: #CashierTest #test04CannotCheckoutACartWithAnExpiredCreditCard stamp: 'cmmmmm 11/4/2019 20:27:24'!
ERROR!

!testRun: #CashierTest #test04CannotCheckoutACartWithAnExpiredCreditCard stamp: 'cmmmmm 11/4/2019 20:27:35'!
ERROR!
!Cashier class methodsFor: 'instance creation' stamp: 'cmmmmm 11/4/2019 20:27:43'!
                          with: anOrderedCollection onDate: aGregorianMonthOfYear 
	"DO NOT FORGET TO RENAME COLLABORATORS AND REMOVE THIS COMMENT!!!!"
	self shouldBeImplemented.
	^self new initializeWith: anOrderedCollection onDate: aGregorianMonthOfYear ! !
!Cashier class methodsFor: 'instance creation' stamp: 'cmmmmm 11/4/2019 20:28:18' prior: 50334521!
                   with: anOrderedCollection onDate: aGregorianMonthOfYear 

	^self new initializeWith: anOrderedCollection onDate: aGregorianMonthOfYear ! !
!Cashier class methodsFor: 'instance creation' stamp: 'cmmmmm 11/4/2019 20:30:01' prior: 50334532!
                  with: aSalesBook onDate: aGregorianMonthOfYear 

	^self new initializeWith: aSalesBook onDate: aGregorianMonthOfYear  .! !

!testRun: #CashierTest #test01NewCashierWith stamp: 'cmmmmm 11/4/2019 20:30:16'!
PASSED!

!testRun: #CashierTest #test02CheckoutACartWith1ElementIsCorrect stamp: 'cmmmmm 11/4/2019 20:30:16'!
PASSED!

!testRun: #CashierTest #test03CheckoutACartWithSeveralElementGivesCorrectSubtotal stamp: 'cmmmmm 11/4/2019 20:30:16'!
PASSED!

!testRun: #CashierTest #test04CannotCheckoutACartWithAnExpiredCreditCard stamp: 'cmmmmm 11/4/2019 20:30:16'!
ERROR!

!testRun: #CashierTest #test04CannotCheckoutACartWithAnInvalidCreditCard stamp: 'cmmmmm 11/4/2019 20:30:16'!
ERROR!

!methodRemoval: CashierTest #test04CannotCheckoutACartWithAnInvalidCreditCard stamp: 'cmmmmm 11/4/2019 20:30:29'!
test04CannotCheckoutACartWithAnInvalidCreditCard

	| aCashier aCatalog aCart aCard aDate|
	
	aDate := GregorianMonthOfYear current .
	aCatalog := Dictionary new.
	aCashier := Cashier with: OrderedCollection new.
	aCard := CreditCard withNumber: 123123123 expirationDate: aDate owner: 'San Martin'.
	
	aCatalog add:'validBook'->100.
	aCart := Cart acceptingItemsOf: aCatalog.
	
	aCart add: 'validBook'.
	
	self assert: 150 equals: (aCashier checkOut: aCart) .	

		
		 !

!testRun: #CashierTest #test04CannotCheckoutACartWithAnExpiredCreditCard stamp: 'cmmmmm 11/4/2019 20:30:30'!
ERROR!

!classDefinition: #Cashier category: #TusLibros stamp: 'cmmmmm 11/4/2019 20:30:44'!
Object subclass: #Cashier
	instanceVariableNames: 'salesBook gregorianMonthOfYear'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!Cashier methodsFor: 'initialization' stamp: 'cmmmmm 11/4/2019 20:30:44'!
                               initializeWith: aSalesBook onDate: aGregorianMonthOfYear 
	self shouldBeImplemented.
	salesBook := aSalesBook.
	gregorianMonthOfYear := aGregorianMonthOfYear.! !

!classDefinition: #Cashier category: #TusLibros stamp: 'cmmmmm 11/4/2019 20:31:04'!
Object subclass: #Cashier
	instanceVariableNames: 'salesBook gregorianMonthOfYear currentDate'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!Cashier methodsFor: 'initialization' stamp: 'cmmmmm 11/4/2019 20:31:02' prior: 50334594!
          initializeWith: aSalesBook onDate: aGregorianMonthOfYear 
	
	salesBook := aSalesBook.
	currentDate := aGregorianMonthOfYear.! !

!testRun: #CashierTest #test04CannotCheckoutACartWithAnExpiredCreditCard stamp: 'cmmmmm 11/4/2019 20:31:08'!
FAILURE!
!CashierTest methodsFor: 'as yet unclassified' stamp: 'cmmmmm 11/4/2019 20:31:30' prior: 50334485!
      test04CannotCheckoutACartWithAnExpiredCreditCard

	| aCashier aCatalog aCart aCard anExpiredDate aCurrentDate|
	
	anExpiredDate := GregorianMonthOfYear decemberOf: 2018.
	aCurrentDate := GregorianMonthOfYear decemberOf: 2019.
	
	aCatalog := Dictionary new.
	aCashier := Cashier with: OrderedCollection new onDate: aCurrentDate.
	aCard := CreditCard withNumber: (10 raisedToInteger: 15) expirationDate: anExpiredDate owner: 'San Martin'.
	
	aCatalog add:'validBook'->100.
	aCart := Cart acceptingItemsOf: aCatalog.
	
	aCart add: 'validBook'.	

	self should: [ aCashier checkOut: aCart withCard: aCard ]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [ :anError |
			self assert: anError messageText = Cashier cartCanNotBeEmpty.
			]
		
		 ! !

!testRun: #CashierTest #test04CannotCheckoutACartWithAnExpiredCreditCard stamp: 'cmmmmm 11/4/2019 20:31:32'!
ERROR!
!Cashier methodsFor: 'as yet unclassified' stamp: 'cmmmmm 11/4/2019 20:31:42'!
            checkOut: aCart withCard: aCreditCard 
	self shouldBeImplemented.! !
!Cashier methodsFor: 'as yet unclassified' stamp: 'cmmmmm 11/4/2019 20:33:17' prior: 50334651!
                            checkOut: aCart withCard: aCreditCard
	
	aCreditCard date < currentDate ifTrue: [self error: Cashier creditCardExpired.].
	aCart isEmpty ifTrue: [self error: Cashier cartCanNotBeEmpty.]
	ifFalse: [ ^ aCart subtotal ]! !

!testRun: #CashierTest #test04CannotCheckoutACartWithAnExpiredCreditCard stamp: 'cmmmmm 11/4/2019 20:33:26'!
ERROR!
!CreditCard methodsFor: 'as yet unclassified' stamp: 'cmmmmm 11/4/2019 20:33:34'!
                             date
	self shouldBeImplemented.! !
!CreditCard methodsFor: 'as yet unclassified' stamp: 'cmmmmm 11/4/2019 20:33:41' prior: 50334671!
                           date
	^expirationDate ! !

!testRun: #CashierTest #test04CannotCheckoutACartWithAnExpiredCreditCard stamp: 'cmmmmm 11/4/2019 20:33:43'!
ERROR!
!Cashier class methodsFor: 'as yet unclassified' stamp: 'cmmmmm 11/4/2019 20:33:56'!
                            creditCardExpired
	self shouldBeImplemented.! !
!Cashier class methodsFor: 'as yet unclassified' stamp: 'cmmmmm 11/4/2019 20:34:06' prior: 50334684!
           creditCardExpired
	^'credit card expired'! !

!testRun: #CashierTest #test04CannotCheckoutACartWithAnExpiredCreditCard stamp: 'cmmmmm 11/4/2019 20:34:07'!
FAILURE!
!CashierTest methodsFor: 'as yet unclassified' stamp: 'cmmmmm 11/4/2019 20:34:23' prior: 50334621!
                         test04CannotCheckoutACartWithAnExpiredCreditCard

	| aCashier aCatalog aCart aCard anExpiredDate aCurrentDate|
	
	anExpiredDate := GregorianMonthOfYear decemberOf: 2018.
	aCurrentDate := GregorianMonthOfYear decemberOf: 2019.
	
	aCatalog := Dictionary new.
	aCashier := Cashier with: OrderedCollection new onDate: aCurrentDate.
	aCard := CreditCard withNumber: (10 raisedToInteger: 15) expirationDate: anExpiredDate owner: 'San Martin'.
	
	aCatalog add:'validBook'->100.
	aCart := Cart acceptingItemsOf: aCatalog.
	
	aCart add: 'validBook'.	

	self should: [ aCashier checkOut: aCart withCard: aCard ]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [ :anError |
			self assert: anError messageText = Cashier creditCardExpired .
			]
		
		 ! !

!testRun: #CashierTest #test04CannotCheckoutACartWithAnExpiredCreditCard stamp: 'cmmmmm 11/4/2019 20:34:26'!
PASSED!

!testRun: #CashierTest #test01NewCashierWith stamp: 'cmmmmm 11/4/2019 20:34:26'!
PASSED!

!testRun: #CashierTest #test02CheckoutACartWith1ElementIsCorrect stamp: 'cmmmmm 11/4/2019 20:34:26'!
PASSED!

!testRun: #CashierTest #test03CheckoutACartWithSeveralElementGivesCorrectSubtotal stamp: 'cmmmmm 11/4/2019 20:34:26'!
PASSED!

!testRun: #CashierTest #test04CannotCheckoutACartWithAnExpiredCreditCard stamp: 'cmmmmm 11/4/2019 20:34:26'!
PASSED!

!testRun: #CashierTest #test01NewCashierWith stamp: 'cmmmmm 11/4/2019 20:34:31'!
PASSED!

!testRun: #CashierTest #test02CheckoutACartWith1ElementIsCorrect stamp: 'cmmmmm 11/4/2019 20:34:31'!
PASSED!

!testRun: #CashierTest #test03CheckoutACartWithSeveralElementGivesCorrectSubtotal stamp: 'cmmmmm 11/4/2019 20:34:31'!
PASSED!

!testRun: #CashierTest #test04CannotCheckoutACartWithAnExpiredCreditCard stamp: 'cmmmmm 11/4/2019 20:34:31'!
PASSED!

----STARTUP---- (6 November 2019 16:11:34) as /home/lsomacal/Escritorio/linux64/CuisUniversity-3938.image!


!classRemoval: #Cashier stamp: 'LS 11/6/2019 16:11:42'!
Object subclass: #Cashier
	instanceVariableNames: 'dictionary catalog'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classRemoval: #Cart stamp: 'LS 11/6/2019 16:11:42'!
Object subclass: #Cart
	instanceVariableNames: 'catalog items'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classRemoval: #CashierTest stamp: 'LS 11/6/2019 16:11:42'!
TestCase subclass: #CashierTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classRemoval: #CartTest stamp: 'LS 11/6/2019 16:11:43'!
TestCase subclass: #CartTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

TestCase subclass: #CartTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #CartTest category: #TusLibros stamp: 'LS 11/6/2019 16:11:54'!
TestCase subclass: #CartTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!CartTest methodsFor: 'tests' stamp: 'HernanWilkinson 6/17/2013 17:08'!
    test01NewCartsAreCreatedEmpty

	self assert: self createCart isEmpty! !
!CartTest methodsFor: 'tests' stamp: 'HernanWilkinson 6/17/2013 17:45'!
                test02CanNotAddItemsThatDoNotBelongToStore

	| cart |
	
	cart := self createCart.
	
	self 
		should: [ cart add: self itemNotSellByTheStore ]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [ :anError |
			self assert: anError messageText = cart invalidItemErrorMessage.
			self assert: cart isEmpty ]! !
!CartTest methodsFor: 'tests' stamp: 'HernanWilkinson 6/17/2013 17:43'!
                              test03AfterAddingAnItemTheCartIsNotEmptyAnymore

	| cart |
	
	cart := self createCart.
	
	cart add: self itemSellByTheStore.
	self deny: cart isEmpty ! !
!CartTest methodsFor: 'tests' stamp: 'HernanWilkinson 6/17/2013 17:43'!
                              test04CanNotAddNonPositiveNumberOfItems

	| cart |
	
	cart := self createCart.
	
	self 
		should: [cart add: 0 of: self itemSellByTheStore ]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [ :anError |
			self assert: anError messageText = cart invalidQuantityErrorMessage.
			self assert: cart isEmpty ]! !
!CartTest methodsFor: 'tests' stamp: 'HernanWilkinson 6/17/2013 17:45'!
                           test05CanNotAddMoreThanOneItemNotSellByTheStore

	| cart |
	
	cart := self createCart.
	
	self 
		should: [cart add: 2 of: self itemNotSellByTheStore  ]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [ :anError |
			self assert: anError messageText = cart invalidItemErrorMessage.
			self assert: cart isEmpty ]! !
!CartTest methodsFor: 'tests' stamp: 'HernanWilkinson 6/17/2013 17:43'!
                   test06CartRemembersAddedItems

	| cart |
	
	cart := self createCart.
	
	cart add: self itemSellByTheStore.
	self assert: (cart includes: self itemSellByTheStore)! !
!CartTest methodsFor: 'tests' stamp: 'HernanWilkinson 6/17/2013 17:43'!
                   test07CartDoesNotHoldNotAddedItems

	| cart |
	
	cart := self createCart.
	
	self deny: (cart includes: self itemSellByTheStore)! !
!CartTest methodsFor: 'tests' stamp: 'HernanWilkinson 6/17/2013 17:45'!
                    test08CartRemembersTheNumberOfAddedItems

	| cart |
	
	cart := self createCart.
	
	cart add: 2 of: self itemSellByTheStore.
	self assert: (cart occurrencesOf: self itemSellByTheStore) = 2! !
!CartTest methodsFor: 'support' stamp: 'HernanWilkinson 6/17/2013 17:48'!
                       createCart
	
	^Cart acceptingItemsOf: self defaultCatalog! !
!CartTest methodsFor: 'support' stamp: 'HernanWilkinson 6/17/2013 17:43'!
                         defaultCatalog
	
	^ Array with: self itemSellByTheStore! !
!CartTest methodsFor: 'support' stamp: 'HernanWilkinson 6/17/2013 17:44'!
                           itemNotSellByTheStore
	
	^'invalidBook'! !
!CartTest methodsFor: 'support' stamp: 'HernanWilkinson 6/17/2013 17:43'!
           itemSellByTheStore
	
	^ 'validBook'! !

TestCase subclass: #CashierTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #CashierTest category: #TusLibros stamp: 'LS 11/6/2019 16:11:55'!
TestCase subclass: #CashierTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!CashierTest methodsFor: 'as yet unclassified' stamp: 'LS 10/31/2019 21:29:57'!
                 test01NewCashierWith

	| aCashier aCatalog aCart |
	
	aCatalog := Dictionary new.
	aCashier := Cashier with: aCatalog.
	
	aCart := Cart acceptingItemsOf: (Array with: 'validBook').
		
	self should: [ aCashier checkOut: aCart ]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [ :anError |
			self assert: anError messageText = Cashier cartCanNotBeEmpty.
			]
		
		 ! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'cmmmmm 11/4/2019 19:28:22'!
                    test02CheckoutACartWith1ElementIsCorrect

	| aCashier aCatalog aCart |
	
	aCatalog := Dictionary new.
	aCashier := Cashier with: OrderedCollection new.
	
	aCatalog add:'validBook'->100.
	aCart := Cart acceptingItemsOf: aCatalog.
	
	aCart add: 'validBook'.
	
	self assert: 100 equals: (aCashier checkOut: aCart) .	

		
		 ! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'cmmmmm 11/4/2019 19:32:52'!
        test03CheckoutACartWithSeveralElementGivesCorrectSubtotal

	| aCashier aCatalog aCart |
	
	aCatalog := Dictionary new.
	aCashier := Cashier with: OrderedCollection new.
	
	aCatalog add:'validBook'->100; add:'validBook2'->50.
	aCart := Cart acceptingItemsOf: aCatalog.
	
	aCart add: 'validBook'.
	aCart add: 'validBook2'.
	
	self assert: 150 equals: (aCashier checkOut: aCart) .	

		
		 ! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'cmmmmm 11/4/2019 20:34:23'!
       test04CannotCheckoutACartWithAnExpiredCreditCard

	| aCashier aCatalog aCart aCard anExpiredDate aCurrentDate|
	
	anExpiredDate := GregorianMonthOfYear decemberOf: 2018.
	aCurrentDate := GregorianMonthOfYear decemberOf: 2019.
	
	aCatalog := Dictionary new.
	aCashier := Cashier with: OrderedCollection new onDate: aCurrentDate.
	aCard := CreditCard withNumber: (10 raisedToInteger: 15) expirationDate: anExpiredDate owner: 'San Martin'.
	
	aCatalog add:'validBook'->100.
	aCart := Cart acceptingItemsOf: aCatalog.
	
	aCart add: 'validBook'.	

	self should: [ aCashier checkOut: aCart withCard: aCard ]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [ :anError |
			self assert: anError messageText = Cashier creditCardExpired .
			]
		
		 ! !

TestCase subclass: #CreditCardTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #CreditCardTest category: #TusLibros stamp: 'LS 11/6/2019 16:11:55'!
TestCase subclass: #CreditCardTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!CreditCardTest methodsFor: 'as yet unclassified' stamp: 'cmmmmm 11/4/2019 19:51:19'!
                        test01CannotCreateCardWithInvalidNumber
	| aPerson anExpirationDate anId |
	
	aPerson := 'San Martin'.
	anExpirationDate := GregorianMonthOfYear current.
	anId := 0.
	
self should: [  CreditCard withNumber: anId expirationDate: anExpirationDate owner: aPerson ]
	raise: Error - MessageNotUnderstood
	withExceptionDo: [ :anError |
		self assert: anError messageText = CreditCard invalidNumber.
			]! !
!CreditCardTest methodsFor: 'as yet unclassified' stamp: 'cmmmmm 11/4/2019 20:09:18'!
                         test02CannotCreateCardWithInvalidGreaterNumber
	| aPerson anExpirationDate anId |
	
	aPerson := 'San Martin'.
	anExpirationDate := GregorianMonthOfYear current.
	anId := 10 raisedToInteger: 16.
	
self should: [  CreditCard withNumber: anId expirationDate: anExpirationDate owner: aPerson ]
	raise: Error - MessageNotUnderstood
	withExceptionDo: [ :anError |
		self assert: anError messageText = CreditCard invalidNumber.
			]! !
!CreditCardTest methodsFor: 'as yet unclassified' stamp: 'cmmmmm 11/4/2019 20:10:32'!
                             test03CannotCreateCardWithemptyOwner
	| aPerson anExpirationDate anId |
	
	aPerson := ''.
	anExpirationDate := GregorianMonthOfYear current.
	anId := 10 raisedToInteger: 15.
	
self should: [  CreditCard withNumber: anId expirationDate: anExpirationDate owner: aPerson ]
	raise: Error - MessageNotUnderstood
	withExceptionDo: [ :anError |
		self assert: anError messageText = CreditCard invalidOwner.
			]! !

Object subclass: #Cart
	instanceVariableNames: 'catalog items'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #Cart category: #TusLibros stamp: 'LS 11/6/2019 16:11:55'!
Object subclass: #Cart
	instanceVariableNames: 'catalog items'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!Cart methodsFor: 'error messages' stamp: 'HernanWilkinson 6/17/2013 17:45'!
  invalidItemErrorMessage
	
	^'Item is not in catalog'! !
!Cart methodsFor: 'error messages' stamp: 'HernanWilkinson 6/17/2013 17:45'!
                           invalidQuantityErrorMessage
	
	^'Invalid number of items'! !
!Cart methodsFor: 'assertions' stamp: 'cmmmmm 11/4/2019 19:24:33'!
assertIsValidItem: anItem

	(catalog includesKey: anItem) ifFalse: [ self error: self invalidItemErrorMessage ]! !
!Cart methodsFor: 'assertions' stamp: 'HernanWilkinson 6/17/2013 17:51'!
    assertIsValidQuantity: aQuantity

	aQuantity strictlyPositive ifFalse: [ self error: self invalidQuantityErrorMessage ]! !
!Cart methodsFor: 'initialization' stamp: 'HernanWilkinson 6/17/2013 17:48'!
                        initializeAcceptingItemsOf: aCatalog

	catalog := aCatalog.
	items := OrderedCollection new.! !
!Cart methodsFor: 'queries' stamp: 'HernanWilkinson 6/17/2013 17:45'!
                          occurrencesOf: anItem

	^items occurrencesOf: anItem  ! !
!Cart methodsFor: 'testing' stamp: 'HernanWilkinson 6/17/2013 17:44'!
includes: anItem

	^items includes: anItem ! !
!Cart methodsFor: 'testing' stamp: 'HernanWilkinson 6/17/2013 17:44'!
           isEmpty
	
	^items isEmpty ! !
!Cart methodsFor: 'adding' stamp: 'HernanWilkinson 6/17/2013 17:44'!
                             add: anItem

	^ self add: 1 of: anItem ! !
!Cart methodsFor: 'adding' stamp: 'HernanWilkinson 6/17/2013 17:51'!
                add: aQuantity of: anItem

	self assertIsValidQuantity: aQuantity.
	self assertIsValidItem: anItem.

	1 to: aQuantity do: [ :aNumber | items add: anItem ]! !
!Cart methodsFor: 'as yet unclassified' stamp: 'cmmmmm 11/4/2019 19:13:41'!
                      subtotal
	| sum |

	sum _ 0.
	catalog do: [:anItem | sum _ sum + anItem ]. 
	^sum.! !

"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!

Cart class
	instanceVariableNames: ''!

!classDefinition: 'Cart class' category: #TusLibros stamp: 'LS 11/6/2019 16:11:55'!
Cart class
	instanceVariableNames: ''!
!Cart class methodsFor: 'instance creation' stamp: 'HernanWilkinson 6/17/2013 17:48'!
                     acceptingItemsOf: aCatalog

	^self new initializeAcceptingItemsOf: aCatalog ! !

Object subclass: #Cashier
	instanceVariableNames: 'salesBook gregorianMonthOfYear currentDate'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #Cashier category: #TusLibros stamp: 'LS 11/6/2019 16:11:55'!
Object subclass: #Cashier
	instanceVariableNames: 'salesBook gregorianMonthOfYear currentDate'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!Cashier methodsFor: 'initialization' stamp: 'cmmmmm 11/4/2019 19:27:11'!
          initializeWith: aSalesBook
	
	salesBook := aSalesBook.! !
!Cashier methodsFor: 'initialization' stamp: 'cmmmmm 11/4/2019 20:31:02'!
                            initializeWith: aSalesBook onDate: aGregorianMonthOfYear 
	
	salesBook := aSalesBook.
	currentDate := aGregorianMonthOfYear.! !
!Cashier methodsFor: 'as yet unclassified' stamp: 'LS 10/31/2019 21:30:50'!
                    cartCanNotBeEmpty
	self shouldBeImplemented.! !
!Cashier methodsFor: 'as yet unclassified' stamp: 'cmmmmm 11/4/2019 19:32:30'!
 checkOut: aCart 
	
	aCart isEmpty ifTrue: [self error: Cashier cartCanNotBeEmpty.]
	ifFalse: [ ^ aCart subtotal ]! !
!Cashier methodsFor: 'as yet unclassified' stamp: 'cmmmmm 11/4/2019 20:33:17'!
                            checkOut: aCart withCard: aCreditCard
	
	aCreditCard date < currentDate ifTrue: [self error: Cashier creditCardExpired.].
	aCart isEmpty ifTrue: [self error: Cashier cartCanNotBeEmpty.]
	ifFalse: [ ^ aCart subtotal ]! !

"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!

Cashier class
	instanceVariableNames: ''!

!classDefinition: 'Cashier class' category: #TusLibros stamp: 'LS 11/6/2019 16:11:55'!
Cashier class
	instanceVariableNames: ''!
!Cashier class methodsFor: 'instance creation' stamp: 'LS 10/31/2019 21:29:23'!
            cartCanNotBeEmpty
	^'cart can not be empty'! !
!Cashier class methodsFor: 'instance creation' stamp: 'cmmmmm 11/4/2019 19:26:46'!
                              with: aSalesBook 
	
	^self new initializeWith: aSalesBook ! !
!Cashier class methodsFor: 'instance creation' stamp: 'cmmmmm 11/4/2019 20:30:01'!
               with: aSalesBook onDate: aGregorianMonthOfYear 

	^self new initializeWith: aSalesBook onDate: aGregorianMonthOfYear  .! !
!Cashier class methodsFor: 'as yet unclassified' stamp: 'cmmmmm 11/4/2019 20:34:06'!
                creditCardExpired
	^'credit card expired'! !

Object subclass: #CreditCard
	instanceVariableNames: 'id expirationDate person'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #CreditCard category: #TusLibros stamp: 'LS 11/6/2019 16:11:55'!
Object subclass: #CreditCard
	instanceVariableNames: 'id expirationDate person'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!CreditCard methodsFor: 'initialization' stamp: 'cmmmmm 11/4/2019 20:14:54'!
     initializeWithNumber: anId expirationDate: anExpirationDate owner: aPerson 
	
	id := anId.
	expirationDate := anExpirationDate.
	person := aPerson.
	self isValid.! !
!CreditCard methodsFor: 'initialization' stamp: 'cmmmmm 11/4/2019 20:14:34'!
             isValid

	(id between: (10 raisedToInteger: 15) and: ((10 raisedToInteger: 16) -1)) ifFalse: [self error: CreditCard invalidNumber].
	person isEmpty ifTrue: [self error: CreditCard invalidOwner].
	^true.! !
!CreditCard methodsFor: 'as yet unclassified' stamp: 'cmmmmm 11/4/2019 20:33:41'!
                               date
	^expirationDate ! !

"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!

CreditCard class
	instanceVariableNames: ''!

!classDefinition: 'CreditCard class' category: #TusLibros stamp: 'LS 11/6/2019 16:11:55'!
CreditCard class
	instanceVariableNames: ''!
!CreditCard class methodsFor: 'instance creation' stamp: 'cmmmmm 11/4/2019 19:53:38'!
                               withNumber: anId expirationDate: anExpirationDate owner: aPerson 
	
	^self new initializeWithNumber: anId expirationDate: anExpirationDate owner: aPerson ! !
!CreditCard class methodsFor: 'Error Handling' stamp: 'cmmmmm 11/4/2019 19:56:26'!
               invalidNumber
	^'Invalid card Number'.! !
!CreditCard class methodsFor: 'as yet unclassified' stamp: 'cmmmmm 11/4/2019 20:12:01'!
                              invalidOwner
	^'InvalidOwner'.! !

----End fileIn of /home/lsomacal/Escritorio/linux64/TusLibros.st----!
!Cashier methodsFor: 'initialization' stamp: 'LS 11/6/2019 16:12:07' prior: 50335121!
 initializeWith: aSalesBook
	
	salesBook := aSalesBook.
	! !

!testRun: #CashierTest #test01NewCashierWith stamp: 'LS 11/6/2019 16:12:14'!
PASSED!

!testRun: #CashierTest #test02CheckoutACartWith1ElementIsCorrect stamp: 'LS 11/6/2019 16:12:14'!
PASSED!

!testRun: #CashierTest #test03CheckoutACartWithSeveralElementGivesCorrectSubtotal stamp: 'LS 11/6/2019 16:12:14'!
PASSED!

!testRun: #CashierTest #test04CannotCheckoutACartWithAnExpiredCreditCard stamp: 'LS 11/6/2019 16:12:14'!
PASSED!
!CashierTest methodsFor: 'as yet unclassified' stamp: 'LS 11/6/2019 16:16:17' prior: 50334898!
                        test01NewCashierWith

	| aCashier aSalesBook aCart |
	
	aSalesBook := Dictionary new.
	aCashier := Cashier with: aSalesBook.
	
	aCart := Cart acceptingItemsOf: (Array with: 'validBook').
		
	self should: [ aCashier checkOut: aCart ]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [ :anError |
			self assert: anError messageText = Cashier cartCanNotBeEmpty.
			]
		
		 ! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'LS 11/6/2019 16:16:36' prior: 50334913!
  test02CheckoutACartWith1ElementIsCorrect

	| aCashier aSalesBook aCart |
	
	aSalesBook := Dictionary new.
	aCashier := Cashier with: OrderedCollection new.
	
	aSalesBook add:'validBook'->100.
	aCart := Cart acceptingItemsOf: aSalesBook.
	
	aCart add: 'validBook'.
	
	self assert: 100 equals: (aCashier checkOut: aCart) .	

		
		 ! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'LS 11/6/2019 16:20:10' prior: 50335262!
                    test01NewCashierWith

	| aCashier aSalesBook aCart |
	
	aSalesBook := Array new.
	aCashier := Cashier with: aSalesBook.
	
	aCart := Cart acceptingItemsOf: (Dictionary with: 'validBook'->100).
		
	self should: [ aCashier checkOut: aCart ]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [ :anError |
			self assert: anError messageText = Cashier cartCanNotBeEmpty.
			]
		
		 ! !

!testRun: #CashierTest #test01NewCashierWith stamp: 'LS 11/6/2019 16:20:14'!
PASSED!

!testRun: #CashierTest #test01NewCashierWith stamp: 'LS 11/6/2019 16:20:14'!
PASSED!

!testRun: #CashierTest #test02CheckoutACartWith1ElementIsCorrect stamp: 'LS 11/6/2019 16:20:14'!
PASSED!

!testRun: #CashierTest #test03CheckoutACartWithSeveralElementGivesCorrectSubtotal stamp: 'LS 11/6/2019 16:20:14'!
PASSED!

!testRun: #CashierTest #test04CannotCheckoutACartWithAnExpiredCreditCard stamp: 'LS 11/6/2019 16:20:14'!
PASSED!
!CashierTest methodsFor: 'as yet unclassified' stamp: 'LS 11/6/2019 16:21:07' prior: 50335277!
                          test02CheckoutACartWith1ElementIsCorrect

	| aCashier aCatalog aCart |
	
	aCatalog := Dictionary new.
	aCashier := Cashier with: Array new.
	
	aCatalog add:'validBook'->100.
	aCart := Cart acceptingItemsOf: aCatalog.
	
	aCart add: 'validBook'.
	
	self assert: 100 equals: (aCashier checkOut: aCart) .	

		
		 ! !

!testRun: #CashierTest #test02CheckoutACartWith1ElementIsCorrect stamp: 'LS 11/6/2019 16:21:13'!
PASSED!

!testRun: #CashierTest #test01NewCashierWith stamp: 'LS 11/6/2019 16:21:13'!
PASSED!

!testRun: #CashierTest #test02CheckoutACartWith1ElementIsCorrect stamp: 'LS 11/6/2019 16:21:14'!
PASSED!

!testRun: #CashierTest #test03CheckoutACartWithSeveralElementGivesCorrectSubtotal stamp: 'LS 11/6/2019 16:21:14'!
PASSED!

!testRun: #CashierTest #test04CannotCheckoutACartWithAnExpiredCreditCard stamp: 'LS 11/6/2019 16:21:14'!
PASSED!
!CashierTest methodsFor: 'as yet unclassified' stamp: 'LS 11/6/2019 16:21:36' prior: 50335291!
                 test01NewCashierWith

	| aCashier aCart |
	
	aCashier := Cashier with: Array new.
	
	aCart := Cart acceptingItemsOf: (Dictionary with: 'validBook'->100).
		
	self should: [ aCashier checkOut: aCart ]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [ :anError |
			self assert: anError messageText = Cashier cartCanNotBeEmpty.
			]
		
		 ! !

!testRun: #CashierTest #test01NewCashierWith stamp: 'LS 11/6/2019 16:21:37'!
PASSED!

!testRun: #CashierTest #test01NewCashierWith stamp: 'LS 11/6/2019 16:21:37'!
PASSED!

!testRun: #CashierTest #test02CheckoutACartWith1ElementIsCorrect stamp: 'LS 11/6/2019 16:21:37'!
PASSED!

!testRun: #CashierTest #test03CheckoutACartWithSeveralElementGivesCorrectSubtotal stamp: 'LS 11/6/2019 16:21:37'!
PASSED!

!testRun: #CashierTest #test04CannotCheckoutACartWithAnExpiredCreditCard stamp: 'LS 11/6/2019 16:21:37'!
PASSED!
!CashierTest methodsFor: 'as yet unclassified' stamp: 'LS 11/6/2019 16:22:15' prior: 50334926!
test03CheckoutACartWithSeveralElementGivesCorrectSubtotal

	| aCashier aCatalog aCart |
	
	aCatalog := Dictionary new.	
	aCatalog add:'validBook'->100; add:'validBook2'->50.
	aCart := Cart acceptingItemsOf: aCatalog.
	
	aCashier := Cashier with: Array new.
	
	aCart add: 'validBook'.
	aCart add: 'validBook2'.
	
	self assert: 150 equals: (aCashier checkOut: aCart) .	

		
		 ! !

!testRun: #CashierTest #test03CheckoutACartWithSeveralElementGivesCorrectSubtotal stamp: 'LS 11/6/2019 16:22:16'!
PASSED!

!testRun: #CashierTest #test01NewCashierWith stamp: 'LS 11/6/2019 16:22:16'!
PASSED!

!testRun: #CashierTest #test02CheckoutACartWith1ElementIsCorrect stamp: 'LS 11/6/2019 16:22:16'!
PASSED!

!testRun: #CashierTest #test03CheckoutACartWithSeveralElementGivesCorrectSubtotal stamp: 'LS 11/6/2019 16:22:16'!
PASSED!

!testRun: #CashierTest #test04CannotCheckoutACartWithAnExpiredCreditCard stamp: 'LS 11/6/2019 16:22:16'!
PASSED!

TestCase subclass: #TerniLapilliTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!

!classDefinition: #TerniLapilliTest category: #TerniLapilli stamp: 'LS 11/6/2019 16:25:27'!
TestCase subclass: #TerniLapilliTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!
!TerniLapilliTest methodsFor: 'testing' stamp: 'cmmmm 10/17/2019 16:49:24'!
 test01NewGameIsEmpty
	
	| game |
	game := TerniLapilli new.
	
	self assert: 0 equals: game jugadorX cantFichas.
	self assert: 0 equals: game jugadorO cantFichas.
	self assert: true equals: game juegaX.
! !
!TerniLapilliTest methodsFor: 'testing' stamp: 'cmmmm 10/17/2019 16:49:24'!
      test02XStartsPlaying
	
	| game |
	game := TerniLapilli new.
	
	self assert: true equals: game juegaX.
	self assert: false equals: game juegaO.
! !
!TerniLapilliTest methodsFor: 'testing' stamp: 'cmmmm 10/17/2019 16:49:24'!
 test03XPutsInTheCorrectPlace
	
	| game |
	game := TerniLapilli new.
	game putAt: 1@1.
	
	self assert: 1 equals: game jugadorX cantFichas.
	self assert: 0 equals: game jugadorO cantFichas.
	self assert: true equals: (game jugadorX tieneFichaEn: 1@1).
! !
!TerniLapilliTest methodsFor: 'testing' stamp: 'cmmmm 10/17/2019 16:49:24'!
                      test04OPlaysSecond
	
	| game |
	game := TerniLapilli new.
	game putAt: 1@1.
	
	self assert: true equals: game juegaO.
	self assert: false equals: game juegaX.	
	! !
!TerniLapilliTest methodsFor: 'testing' stamp: 'cmmmm 10/17/2019 16:41:19'!
               test05CannotPlayIfNotMyTurn
	
"  Este Test ya no tiene sentido porque cambio la interfaz
	| game |
	game := TerniLapilliXXX new.
	
	self should: [ game putAt: 1@1. ]
		raise: Error - MessageNotUnderstood 
		withMessageText: TerniLapilliXXX invalidPlayerTurn.
	self assert: false equals: (game jugadorO tieneFichaEn: 1@1).			
	"! !
!TerniLapilliTest methodsFor: 'testing' stamp: 'cmmmm 10/17/2019 16:41:31'!
         test06CannotPlayXSecond

"  Este Test ya no tiene sentido porque cambio la interfaz	
	| game |
	game := TerniLapilliXXX new.
	game putAt: 1@1.
	
	self should: [ game putAt: 2@1. ]
		raise: Error - MessageNotUnderstood 
		withMessageText: TerniLapilliXXX invalidPlayerTurn.	
	self assert: false equals: (game jugadorX tieneFichaEn: 2@1)."! !
!TerniLapilliTest methodsFor: 'testing' stamp: 'cmmmm 10/17/2019 16:49:24'!
                               test07XCannotPlayIfPositionIsOccuped
	
	| game |
	game := TerniLapilli new.
	game putAt: 2@2.
	game putAt: 1@1.
	
	self should: [ game putAt: 1@1. ]
		raise: Error - MessageNotUnderstood 
		withMessageText: TerniLapilli invalidPosition.
	self assert: true equals: (game jugadorO tieneFichaEn: 1@1).		
	! !
!TerniLapilliTest methodsFor: 'testing' stamp: 'cmmmm 10/17/2019 16:49:24'!
  test08OCannotPlayIfPositionIsOccuped
	
	| game |
	game := TerniLapilli new.
	game putAt: 1@1.
	
	self should: [ game putAt: 1@1. ]
		raise: Error - MessageNotUnderstood 
		withMessageText: TerniLapilli invalidPosition.
	self assert: true equals: (game jugadorX tieneFichaEn: 1@1).		
	! !
!TerniLapilliTest methodsFor: 'testing' stamp: 'cmmmm 10/17/2019 16:49:24'!
                    test09OCannotPlayIfPositionOfLimits
	
	| game |
	game := TerniLapilli new.
	game putAt: 1@1.
	
	self should: [ game putAt: 4@4. ]
		raise: Error - MessageNotUnderstood 
		withMessageText: TerniLapilli invalidPosition.
	self assert: false equals: (game jugadorO tieneFichaEn: 4@4).		
	! !
!TerniLapilliTest methodsFor: 'testing' stamp: 'cmmmm 10/17/2019 16:49:24'!
                    test10XCannotPlayIfPositionOfLimits
	
	| game |
	game := TerniLapilli new.
	
	self should: [ game putAt: 0@0. ]
		raise: Error - MessageNotUnderstood 
		withMessageText: TerniLapilli invalidPosition.
	self assert: false equals: (game jugadorX tieneFichaEn: 0@0).	
	! !
!TerniLapilliTest methodsFor: 'testing' stamp: 'cmmmm 10/17/2019 16:50:15'!
       test11CannotPlayIf6ThereAre6FichasOnTheGame
	
	| game |
	game := TerniLapilli new.
	self fillBoard: game.
	
	self should: [ game putAt: 3@3. ]
		raise: Error - MessageNotUnderstood 
		withMessageText: TerniLapilli invalidPlayBoardFull.
	self assert: false equals: (game jugadorX tieneFichaEn: 3@3).		
	
	! !
!TerniLapilliTest methodsFor: 'testing' stamp: 'cmmmm 10/17/2019 16:51:15'!
test12CannotMoveFichasIfThereAreLessThan6FichasOnTheGame
	
	| game |
	game := TerniLapilli new.
	game putAt: 1@1.
	
	self should: [ game moveFrom: 1@1 to:1@2. ]
		raise: Error - MessageNotUnderstood 
		withMessageText: TerniLapilli invalidPlayBoardNotFull.
	self assert: false equals: (game jugadorX tieneFichaEn: 1@2).! !
!TerniLapilliTest methodsFor: 'testing' stamp: 'cmmmm 10/17/2019 16:50:38'!
                 test13AValidMoveIfThereAre6FichasChangesThePositionOfTheFicha
	
	| game |
	game := TerniLapilli new.
	self fillBoard: game. 		
	game moveFrom: 2@2 to:3@2.

	self assert: true equals: (game jugadorX tieneFichaEn: 3@2).
	self assert: false equals: (game jugadorX tieneFichaEn: 2@2).	! !
!TerniLapilliTest methodsFor: 'testing' stamp: 'cmmmm 10/17/2019 16:50:54'!
                       test14OMAkesValidMoveIfThereAre6FichasChangesThePositionOfTheFichas
	
	| game |
	game := TerniLapilli new.
	self fillBoard: game.
	game moveFrom: 2@2 to:3@2.
	game moveFrom: 2@1 to:3@1.


	self assert: true equals: (game jugadorO tieneFichaEn: 3@1).
	self assert: false equals: (game jugadorO tieneFichaEn: 2@1).! !
!TerniLapilliTest methodsFor: 'testing' stamp: 'cmmmm 10/17/2019 16:49:24'!
                        test15XCantMakeMoveToAPointWichIsNotANeighboar
	
	| game |
	game := TerniLapilli new.
	self fillBoard: game.
	
	self should: [ game moveFrom: 1@1 to:3@2. ]
		raise: Error - MessageNotUnderstood 
		withMessageText: TerniLapilli invalidMove .
	self assert: false equals: (game jugadorX tieneFichaEn: 3@2).! !
!TerniLapilliTest methodsFor: 'testing' stamp: 'cmmmm 10/17/2019 16:49:24'!
 test16OCantMakeMoveToAPointWichIsNotANeighboar
	
	| game |
	game := TerniLapilli new.
	self fillBoard: game.
	game moveFrom: 2@2 to:3@2.
	
	self should: [ game moveFrom: 1@2 to:3@3. ]
		raise: Error - MessageNotUnderstood 
		withMessageText: TerniLapilli invalidMove .
	self assert: false equals: (game jugadorO tieneFichaEn: 3@3).		
! !
!TerniLapilliTest methodsFor: 'testing' stamp: 'cmmmm 10/17/2019 16:49:24'!
  test17GameIsNotOverAfter1PlayAndNobodyHasWon
	
	| game |
	game := TerniLapilli new.
	game putAt: 1@1.
	
	self assert: false equals: (game isOver).
	self assert: false equals: (game hasPlayerXWon).
	self assert: false equals: (game hasPlayerOWon).! !
!TerniLapilliTest methodsFor: 'testing' stamp: 'cmmmm 10/17/2019 16:49:24'!
                          test18OWinsByMaking3PlaysInALineAndGameIsOver
	
	| game |
	game := TerniLapilli new.
	game putAt: 3@3.
	game putAt: 1@1.
	game putAt: 2@1.
	game putAt: 1@2.
	game putAt: 2@2.
	game putAt: 1@3.

	self assert: true equals: (game hasPlayerOWon).
	self assert: true equals: (game isOver).! !
!TerniLapilliTest methodsFor: 'testing' stamp: 'cmmmm 10/17/2019 16:49:24'!
                    test19XWinsByMaking3PlaysInTheMiddleLineAndGameIsOver
	
	| game |
	game := TerniLapilli new.
	game putAt: 2@1.
	game putAt: 1@1.
	game putAt: 2@2.
	game putAt: 1@2.
	game putAt: 2@3.

	self assert: true equals: (game hasPlayerXWon).
	self assert: true equals: (game isOver).! !
!TerniLapilliTest methodsFor: 'testing' stamp: 'cmmmm 10/17/2019 16:49:24'!
                              test20XWinsByMaking3PlaysInTheTopLineAndGameIsOver
	
	| game |
	game := TerniLapilli new.
	game putAt: 3@1.
	game putAt: 1@2.
	game putAt: 3@2.
	game putAt: 1@3.
	game putAt: 3@3.

	self assert: true equals: (game hasPlayerXWon).
	self assert: true equals: (game isOver).! !
!TerniLapilliTest methodsFor: 'testing' stamp: 'cmmmm 10/17/2019 16:49:24'!
 test21XWinsByMaking3PlaysInTheDiagonalAndGameIsOver
	
	| game |
	game := TerniLapilli new.
	game putAt: 1@1.
	game putAt: 1@2.
	game putAt: 2@2.
	game putAt: 1@3.
	game putAt: 3@3.

	self assert: true equals: (game hasPlayerXWon).
	self assert: true equals: (game isOver).! !
!TerniLapilliTest methodsFor: 'testing' stamp: 'cmmmm 10/17/2019 16:49:24'!
test22XWinsByMaking3PlaysInBottomLineAndGameIsOver
	
	| game |
	game := TerniLapilli new.
	game putAt: 1@1.
	game putAt: 1@2.
	game putAt: 2@1.
	game putAt: 1@3.
	game putAt: 3@1.

	self assert: true equals: (game hasPlayerXWon).
	self assert: true equals: (game isOver).! !
!TerniLapilliTest methodsFor: 'testing' stamp: 'cmmmm 10/17/2019 16:49:24'!
 test23XWinsByMaking3PlaysInBottomLineAndGameIsOver
	
	| game |
	game := TerniLapilli new.
	self fillBoard: game.
	game moveFrom: 2@2 to: 3@3. 
	
	
	self should: [ game moveFrom: 2@3 to: 3@2. ]
		raise: Error - MessageNotUnderstood 
		withMessageText: TerniLapilli invalidMove .
	self assert: false equals: (game jugadorO tieneFichaEn: 3@2).
! !
!TerniLapilliTest methodsFor: 'testing' stamp: 'cmmmm 10/17/2019 16:49:24'!
                           test24GameIsTiedAfterSeveralPlays
	
	| game |
	game := TerniLapilli new.
	self fillBoard: game.
	game moveFrom: 2@2 to: 3@3. 
	
	self assert: true equals: (game isTied).	
	self assert: false equals: (game isOver).
! !
!TerniLapilliTest methodsFor: 'setUp/tearDown' stamp: 'LS 10/17/2019 01:00:05'!
                      fillBoard: aGame
	
	aGame putAt: 1@1.
	aGame putAt: 1@2.
	aGame putAt: 1@3.
	aGame putAt: 2@1.
	aGame putAt: 2@2.
	aGame putAt: 2@3.		
! !

Object subclass: #Jugador
	instanceVariableNames: 'fichasJugadas'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!

!classDefinition: #Jugador category: #TerniLapilli stamp: 'LS 11/6/2019 16:25:27'!
Object subclass: #Jugador
	instanceVariableNames: 'fichasJugadas'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!
!Jugador methodsFor: 'accesing' stamp: 'LS 10/16/2019 18:00:48'!
         cantFichas
	^fichasJugadas size.! !
!Jugador methodsFor: 'accesing' stamp: 'LS 10/16/2019 17:58:41'!
                           fichasJugadas
	^fichasJugadas ! !
!Jugador methodsFor: 'accesing' stamp: 'LS 10/16/2019 19:43:21'!
                             tieneFichaEn: aPoint

	^fichasJugadas includes: aPoint! !
!Jugador methodsFor: 'plays' stamp: 'cmmmm 10/17/2019 16:49:24'!
     moveFrom: aPointSource to: aPointDestination
	
	self fichasJugadas remove: aPointSource ifAbsent: [self error: TerniLapilli invalidMove].
	self putAt: aPointDestination.! !
!Jugador methodsFor: 'plays' stamp: 'cmmmm 10/17/2019 16:49:24'!
                  putAt: aPoint 
	
	(aPoint x between: 1 and: 3) ifFalse: [ self error: TerniLapilli invalidPosition ].
	(aPoint y between: 1 and: 3) ifFalse: [ self error: TerniLapilli invalidPosition ].
	
	self fichasJugadas add: aPoint.! !
!Jugador methodsFor: 'initialization' stamp: 'LS 10/16/2019 17:52:51'!
                        initialize
	
	fichasJugadas := Bag new.! !

Object subclass: #TerniLapilli
	instanceVariableNames: 'jugadorX jugadorO jugadorActual'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!

!classDefinition: #TerniLapilli category: #TerniLapilli stamp: 'LS 11/6/2019 16:25:27'!
Object subclass: #TerniLapilli
	instanceVariableNames: 'jugadorX jugadorO jugadorActual'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!
!TerniLapilli methodsFor: 'accessing' stamp: 'cmmmm 10/17/2019 15:17:16'!
             isOver
	self XHizoLinea ifTrue: [^true]. 
	self OHizoLinea ifTrue: [^true]. 
	^false.! !
!TerniLapilli methodsFor: 'accessing' stamp: 'cmmmm 10/17/2019 16:45:24'!
                             isTied
	^self isOver not.! !
!TerniLapilli methodsFor: 'accessing' stamp: 'LS 10/17/2019 00:23:08'!
                            jugadorActual

	^jugadorActual ! !
!TerniLapilli methodsFor: 'accessing' stamp: 'LS 10/16/2019 21:49:52'!
                      jugadorO
	^jugadorO ! !
!TerniLapilli methodsFor: 'accessing' stamp: 'LS 10/16/2019 20:35:55'!
 jugadorX
	^jugadorX ! !
!TerniLapilli methodsFor: 'plays' stamp: 'cmmmm 10/17/2019 16:49:24'!
  moveFrom: aPointSource to: aPointDestination
	
	self cantidadTotalDeFichas = 6 ifFalse: [self error: TerniLapilli invalidPlayBoardNotFull].
	(self estaEnDiagonal: aPointSource) ifTrue: [(aPointSource eightNeighbors includes: aPointDestination) ifFalse: [self error: TerniLapilli invalidMove].]
									ifFalse:[(aPointSource fourNeighbors includes: aPointDestination) ifFalse: [self error: TerniLapilli invalidMove].].
	
	
	jugadorActual moveFrom: aPointSource to: aPointDestination.
	self cambiarJugadorActual.! !
!TerniLapilli methodsFor: 'plays' stamp: 'cmmmm 10/17/2019 16:49:24'!
                      putAt: aPoint 
	(self cantidadTotalDeFichas  = 6) ifTrue: [ self error: TerniLapilli invalidPlayBoardFull ].
	(aPoint x between: 1 and: 3) ifFalse: [ self error: TerniLapilli invalidPosition ].
	(aPoint y between: 1 and: 3) ifFalse: [ self error: TerniLapilli invalidPosition ].
	
	(self isEmpty: aPoint) ifFalse: [ self error: TerniLapilli invalidPosition.] ifTrue: [ jugadorActual putAt: aPoint].
	
	self cambiarJugadorActual.	! !
!TerniLapilli methodsFor: 'initialization' stamp: 'cmmmm 10/17/2019 16:49:12'!
initialize
	
	jugadorX := Jugador new.
	jugadorO := Jugador new.
	jugadorActual := jugadorX.
	! !
!TerniLapilli methodsFor: 'characteristics' stamp: 'LS 10/16/2019 21:52:08'!
                 isEmpty: aPoint 

	^(jugadorO tieneFichaEn: aPoint) not and: (jugadorX tieneFichaEn: aPoint) not.! !
!TerniLapilli methodsFor: 'characteristics' stamp: 'LS 10/17/2019 00:23:55'!
              juegaO

	^ jugadorActual == jugadorO .! !
!TerniLapilli methodsFor: 'characteristics' stamp: 'LS 10/17/2019 00:24:08'!
         juegaX
		
	^jugadorActual  == jugadorX .! !
!TerniLapilli methodsFor: 'private' stamp: 'cmmmm 10/17/2019 15:45:43'!
            OHizoLinea
	^self hizoLinea: jugadorO 	
	! !
!TerniLapilli methodsFor: 'private' stamp: 'cmmmm 10/17/2019 15:45:54'!
           XHizoLinea
	^self hizoLinea: jugadorX 	
	! !
!TerniLapilli methodsFor: 'private' stamp: 'cmmmm 10/17/2019 16:56:10'!
           cambiarJugadorActual

	jugadorActual == jugadorX ifTrue: [jugadorActual := jugadorO] ifFalse: [jugadorActual := jugadorX].! !
!TerniLapilli methodsFor: 'private' stamp: 'LS 10/17/2019 00:40:07'!
                             cantidadTotalDeFichas
	
	^jugadorX cantFichas + jugadorO cantFichas.! !
!TerniLapilli methodsFor: 'private' stamp: 'cmmmm 10/17/2019 16:31:18'!
                estaEnDiagonal: aPoint 
	^(aPoint x + aPoint y) even.! !
!TerniLapilli methodsFor: 'private' stamp: 'cmmmm 10/17/2019 15:36:50'!
                               hasPlayerOWon
	^self OHizoLinea.! !
!TerniLapilli methodsFor: 'private' stamp: 'cmmmm 10/17/2019 15:35:59'!
                    hasPlayerXWon
	^self XHizoLinea.! !
!TerniLapilli methodsFor: 'private' stamp: 'cmmmm 10/17/2019 16:58:07'!
                    hizoLinea: aPlayer

	^(self hizoLineaDiagonal: aPlayer) or: (self hizoLineaVertical: aPlayer) or: (self hizoLineaHorizontal: aPlayer).
	! !
!TerniLapilli methodsFor: 'private' stamp: 'cmmmm 10/17/2019 16:11:01'!
            hizoLineaDiagonal: aPlayer
	| b |
	b := aPlayer fichasJugadas.
	
	^((b includes: 1@1) and: (b includes: 2@2) and: (b includes: 3@3))or:
	((b includes: 1@3) and: (b includes: 2@2) and: (b includes: 3@1)).! !
!TerniLapilli methodsFor: 'private' stamp: 'cmmmm 10/17/2019 16:19:12'!
         hizoLineaHorizontal: aPlayer
	| b |
	b := aPlayer fichasJugadas.
	
	^((b includes: 1@1) and: (b includes: 2@1) and: (b includes: 3@1))or:
	((b includes: 1@2) and: (b includes: 2@2) and: (b includes: 3@2)) or:
	((b includes: 1@3) and: (b includes: 2@3) and: (b includes: 3@3)).! !
!TerniLapilli methodsFor: 'private' stamp: 'cmmmm 10/17/2019 16:16:16'!
hizoLineaVertical: aPlayer
	| b |
	b := aPlayer fichasJugadas.
	
	^((b includes: 1@1) and: (b includes: 1@2) and: (b includes: 1@3))or:
	((b includes: 2@1) and: (b includes: 2@2) and: (b includes: 2@3)) or:
	((b includes: 3@1) and: (b includes: 3@2) and: (b includes: 3@3)).! !

"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!

TerniLapilli class
	instanceVariableNames: ''!

!classDefinition: 'TerniLapilli class' category: #TerniLapilli stamp: 'LS 11/6/2019 16:25:28'!
TerniLapilli class
	instanceVariableNames: ''!
!TerniLapilli class methodsFor: 'error handling' stamp: 'cmmmm 10/15/2019 17:37:26'!
                           invalidMove
	^'invalid move'.! !
!TerniLapilli class methodsFor: 'error handling' stamp: 'cmmmm 10/15/2019 16:14:46'!
          invalidPlayBoardFull
	^'Invalid Play board is Full'! !
!TerniLapilli class methodsFor: 'error handling' stamp: 'cmmmm 10/15/2019 16:15:09'!
                    invalidPlayBoardNotFull
	^'Invalid move board not full'.! !
!TerniLapilli class methodsFor: 'error handling' stamp: 'cmmmmm 10/10/2019 20:10:16'!
              invalidPlayerTurn
	^'invalidPlayerTurn'! !
!TerniLapilli class methodsFor: 'error handling' stamp: 'cmmm 10/15/2019 00:38:41'!
 invalidPosition
		^'invalidPosition'! !

----End fileIn of /home/lsomacal/Escritorio/ejerciciosIS1/TerniLapilli/TerniLapilli.st----!

TestCase subclass: #MarsRoverTest
	instanceVariableNames: 'marsRover'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRoverTDD'!

!classDefinition: #MarsRoverTest category: #MarsRoverTDD stamp: 'LS 11/6/2019 16:25:58'!
TestCase subclass: #MarsRoverTest
	instanceVariableNames: 'marsRover'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRoverTDD'!
!MarsRoverTest methodsFor: 'tests for invalid inputs' stamp: 'cmmmmm 10/10/2019 15:42:21'!
       test01EmptyStringDoesNotChange
	
	marsRover move: ''.
	self assert: marsRover IsIn: 1@1  pointing: Norte new. 
	! !
!MarsRoverTest methodsFor: 'tests for invalid inputs' stamp: 'LS 10/9/2019 21:14:03'!
                      test06InvalidStringRaiseError
	
	self should: [ marsRover move: 'x'. ]
		raise: Error - MessageNotUnderstood 
		withMessageText: MarsRover invalidCommandMessage.! !
!MarsRoverTest methodsFor: 'tests for 1 move' stamp: 'cmmmmm 10/10/2019 15:42:57'!
        test02StringWithFMovesForwardAndDoesNotChangeDirection
	
	marsRover move: 'f'.
	self assert: marsRover IsIn: 1@2  pointing: Norte new. 
! !
!MarsRoverTest methodsFor: 'tests for 1 move' stamp: 'cmmmmm 10/10/2019 15:43:22'!
 test03StringWithBMovesBackwardsAndDoesNotChangeDirection
	
	marsRover move: 'b'.
	self assert: marsRover IsIn: 1@0  pointing: Norte new. 
! !
!MarsRoverTest methodsFor: 'tests for 1 move' stamp: 'cmmmmm 10/10/2019 15:43:39'!
                               test04StringWithRRotatesRightAndDoesNotChangePosition
	
	marsRover move: 'r'.
	self assert: marsRover IsIn: 1@1  pointing: Este new. 
! !
!MarsRoverTest methodsFor: 'tests for 1 move' stamp: 'cmmmmm 10/10/2019 15:44:11'!
   test05StringWithLRotatesLeftAndDoesNotChangePosition
	
	marsRover move: 'l'.
	self assert: marsRover IsIn: 1@1  pointing: Oeste new. 
! !
!MarsRoverTest methodsFor: 'tests for several equal moves' stamp: 'cmmmmm 10/10/2019 15:44:27'!
                      test07StringWithManyFMovesSeveralPositionsForwardAndDoesNotChangeDirection
	
	marsRover move: 'ff'.
	self assert: marsRover IsIn: 1@3  pointing: Norte new. 
	! !
!MarsRoverTest methodsFor: 'tests for several equal moves' stamp: 'cmmmmm 10/10/2019 15:44:43'!
                              test08StringWithManyBMovesSeveralPositionsBackwardsAndDoesNotChangeDirection
	
	marsRover move: 'bb'.
	self assert: marsRover IsIn: 1@-1  pointing: Norte new. 
	! !
!MarsRoverTest methodsFor: 'tests for several equal moves' stamp: 'cmmmmm 10/10/2019 15:45:05'!
                           test09StringWithManyRRotatesSeveralDirectionsRightAndDoesNotChangePosition
	
	marsRover move: 'rrr'.
	self assert: marsRover IsIn: 1@1  pointing: Oeste new. 

! !
!MarsRoverTest methodsFor: 'tests for several equal moves' stamp: 'cmmmmm 10/10/2019 15:46:01'!
                             test10StringWithManyLRotatesSeveralDirectionsLeftAndDoesNotChangePosition
	
	marsRover move: 'lll'.
	self assert: marsRover IsIn: 1@1  pointing: Este new. 
	! !
!MarsRoverTest methodsFor: 'tests for different moves' stamp: 'cmmmmm 10/10/2019 15:46:34'!
   test11StringWithRAndFMovesToRightAndChangeDirection
	
	marsRover move: 'rf'.
	self assert: marsRover IsIn: 2@1  pointing: Este new. 
	! !
!MarsRoverTest methodsFor: 'tests for different moves' stamp: 'cmmmmm 10/10/2019 15:46:51'!
                          test12StringWithLAndFMovesToLeftAndChangeDirection
	
	marsRover move: 'lf'.
	self assert: marsRover IsIn: 0@1  pointing: Oeste new. 
	! !
!MarsRoverTest methodsFor: 'tests for different moves' stamp: 'cmmmmm 10/10/2019 15:47:11'!
                          test13StringWith2RAndFMovesDownAndChangeDirection
	
	marsRover move: 'rrf'.
	self assert: marsRover IsIn: 1@0  pointing: Sur new. 
! !
!MarsRoverTest methodsFor: 'tests for different moves' stamp: 'cmmmmm 10/10/2019 15:47:33'!
                             test14StringWithRAndBMovesToLeftAndChangeDirection
	
	marsRover move: 'rb'.
	self assert: marsRover IsIn: 0@1  pointing: Este new. 
	! !
!MarsRoverTest methodsFor: 'tests for different moves' stamp: 'cmmmmm 10/10/2019 15:47:47'!
                           test15StringWithLAndBMovesToRightAndChangeDirection
	
	marsRover move: 'lb'.
	self assert: marsRover IsIn: 2@1  pointing: Oeste new. 
! !
!MarsRoverTest methodsFor: 'tests for different moves' stamp: 'cmmmmm 10/10/2019 15:48:09'!
                          test16StringWith2RAndBMovesUpAndChangeDirection
	
	marsRover move: 'rrb'.
	self assert: marsRover IsIn: 1@2  pointing: Sur new. 
! !
!MarsRoverTest methodsFor: 'setUp/tearDown' stamp: 'cmmmmm 10/8/2019 20:27:35'!
           setUp
	
	marsRover _ MarsRover in: 1@1 oriented: Norte new. ! !
!MarsRoverTest methodsFor: 'assertions' stamp: 'cmmmmm 10/10/2019 15:41:25'!
                   assert: aRover IsIn: aPosition pointing: aDirection
	
	self assert: aPosition equals: aRover position .
	self assert: aDirection equals: aRover direction.
! !

Object subclass: #MarsRover
	instanceVariableNames: 'position direction commandToMovement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRoverTDD'!

!classDefinition: #MarsRover category: #MarsRoverTDD stamp: 'LS 11/6/2019 16:25:58'!
Object subclass: #MarsRover
	instanceVariableNames: 'position direction commandToMovement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRoverTDD'!
!MarsRover methodsFor: 'movement' stamp: 'LS 10/9/2019 21:02:21'!
move: aString
	
	aString do: [:a | self singleMove: a.].

	
	
	
	
	! !
!MarsRover methodsFor: 'accessing' stamp: 'cmmmmm 10/3/2019 21:10:55'!
                  direction

	^direction! !
!MarsRover methodsFor: 'accessing' stamp: 'cmmmmm 10/3/2019 21:08:40'!
                               position

	^position! !
!MarsRover methodsFor: 'initialization' stamp: 'cmmmmm 10/3/2019 21:04:25'!
                            initializeIn: aPoint oriented: aDirection 
	position := aPoint.
	direction := aDirection.! !
!MarsRover methodsFor: 'private' stamp: 'cmmmmm 10/10/2019 16:47:25'!
                             initialize
	
	commandToMovement := Dictionary new.
	commandToMovement add: $f->[self moveTo: direction forward].
	commandToMovement add: $b->[self moveTo: direction backward ].
	commandToMovement add: $r->[direction := direction rotateRight ].
	commandToMovement add: $l->[direction := direction rotateLeft ].
	
! !
!MarsRover methodsFor: 'private' stamp: 'LS 10/9/2019 21:01:35'!
   moveTo: aRelativePosition
	
	^position := position + aRelativePosition.! !
!MarsRover methodsFor: 'private' stamp: 'cmmmmm 10/10/2019 16:47:25'!
               singleMove: aChar

	(commandToMovement at: aChar ifAbsent: [^ self error: MarsRover invalidCommandMessage.]) value.	
	! !

"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!

MarsRover class
	instanceVariableNames: ''!

!classDefinition: 'MarsRover class' category: #MarsRoverTDD stamp: 'LS 11/6/2019 16:25:58'!
MarsRover class
	instanceVariableNames: ''!
!MarsRover class methodsFor: 'initialization' stamp: 'cmmmmm 10/3/2019 21:07:58'!
   in: aPoint oriented: aDirection
	^MarsRover new initializeIn: aPoint oriented: aDirection! !
!MarsRover class methodsFor: 'error description' stamp: 'LS 10/4/2019 17:36:46'!
                  invalidCommandMessage
	^'Invalid command'! !

Object subclass: #PuntoCardinal
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRoverTDD'!

!classDefinition: #PuntoCardinal category: #MarsRoverTDD stamp: 'LS 11/6/2019 16:25:58'!
Object subclass: #PuntoCardinal
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRoverTDD'!
!PuntoCardinal methodsFor: 'movement' stamp: 'LS 10/9/2019 20:53:33'!
          backward

	^self subclassResponsibility ! !
!PuntoCardinal methodsFor: 'movement' stamp: 'LS 10/9/2019 20:33:19'!
              forward

	^self subclassResponsibility! !
!PuntoCardinal methodsFor: 'rotation' stamp: 'cmmmmm 10/10/2019 16:09:23'!
           rotateLeft 

	^self subclassResponsibility.! !
!PuntoCardinal methodsFor: 'rotation' stamp: 'cmmmmm 10/10/2019 16:10:13'!
      rotateRight 

	^self subclassResponsibility.! !

"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!

PuntoCardinal class
	instanceVariableNames: 'uniqueInstance'!

!classDefinition: 'PuntoCardinal class' category: #MarsRoverTDD stamp: 'LS 11/6/2019 16:25:58'!
PuntoCardinal class
	instanceVariableNames: 'uniqueInstance'!
!PuntoCardinal class methodsFor: 'initialization' stamp: 'chris m 10/8/2019 22:07:42'!
initialize

	uniqueInstance := self basicNew ! !
!PuntoCardinal class methodsFor: 'initialization' stamp: 'chris m 10/8/2019 22:07:53'!
                        new 
	
	^uniqueInstance ! !

PuntoCardinal subclass: #Este
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRoverTDD'!

!classDefinition: #Este category: #MarsRoverTDD stamp: 'LS 11/6/2019 16:25:58'!
PuntoCardinal subclass: #Este
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRoverTDD'!
!Este methodsFor: 'movement' stamp: 'LS 10/9/2019 20:47:58'!
                 backward
	
	^(-1@0)! !
!Este methodsFor: 'movement' stamp: 'LS 10/9/2019 20:44:19'!
            forward

	^(1@0)! !
!Este methodsFor: 'rotation' stamp: 'cmmmmm 10/10/2019 16:09:23'!
          rotateLeft
	
	^Norte new! !
!Este methodsFor: 'rotation' stamp: 'cmmmmm 10/10/2019 16:10:13'!
  rotateRight
	
	^Sur new! !

"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!

Este class
	instanceVariableNames: ''!

!classDefinition: 'Este class' category: #MarsRoverTDD stamp: 'LS 11/6/2019 16:25:58'!
Este class
	instanceVariableNames: ''!
!Este class methodsFor: 'initialization' stamp: 'cmmmmm 10/8/2019 17:59:51'!
                      initialize

	uniqueInstance := self basicNew ! !
!Este class methodsFor: 'initialization' stamp: 'cmmmmm 10/8/2019 18:00:02'!
  new 
	
	^uniqueInstance ! !

PuntoCardinal subclass: #Norte
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRoverTDD'!

!classDefinition: #Norte category: #MarsRoverTDD stamp: 'LS 11/6/2019 16:25:58'!
PuntoCardinal subclass: #Norte
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRoverTDD'!
!Norte methodsFor: 'movement' stamp: 'LS 10/9/2019 20:47:47'!
             backward
	
	^(0@-1)! !
!Norte methodsFor: 'movement' stamp: 'LS 10/9/2019 20:45:16'!
           forward

	^(0@1)! !
!Norte methodsFor: 'rotation' stamp: 'cmmmmm 10/10/2019 16:09:23'!
         rotateLeft
	
	^Oeste new! !
!Norte methodsFor: 'rotation' stamp: 'cmmmmm 10/10/2019 16:10:13'!
 rotateRight
	| nuevaDireccion |
	nuevaDireccion := Este new.
	^nuevaDireccion.
	! !

"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!

Norte class
	instanceVariableNames: ''!

!classDefinition: 'Norte class' category: #MarsRoverTDD stamp: 'LS 11/6/2019 16:25:58'!
Norte class
	instanceVariableNames: ''!
!Norte class methodsFor: 'initialization' stamp: 'cmmmmm 10/8/2019 18:00:13'!
                         initialize

	uniqueInstance := self basicNew ! !
!Norte class methodsFor: 'initialization' stamp: 'cmmmmm 10/8/2019 18:00:22'!
 new

	^uniqueInstance ! !

PuntoCardinal subclass: #Oeste
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRoverTDD'!

!classDefinition: #Oeste category: #MarsRoverTDD stamp: 'LS 11/6/2019 16:25:58'!
PuntoCardinal subclass: #Oeste
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRoverTDD'!
!Oeste methodsFor: 'movement' stamp: 'LS 10/9/2019 20:47:23'!
               backward

	^(1@0)! !
!Oeste methodsFor: 'movement' stamp: 'LS 10/9/2019 20:45:43'!
             forward

	^(-1@0)! !
!Oeste methodsFor: 'rotation' stamp: 'cmmmmm 10/10/2019 16:09:23'!
        rotateLeft
	
	^Sur new! !
!Oeste methodsFor: 'rotation' stamp: 'cmmmmm 10/10/2019 16:10:13'!
   rotateRight
	
	^Norte new! !

"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!

Oeste class
	instanceVariableNames: ''!

!classDefinition: 'Oeste class' category: #MarsRoverTDD stamp: 'LS 11/6/2019 16:25:58'!
Oeste class
	instanceVariableNames: ''!
!Oeste class methodsFor: 'initialization' stamp: 'cmmmmm 10/8/2019 18:00:29'!
                initialize

	uniqueInstance := self basicNew ! !
!Oeste class methodsFor: 'initialization' stamp: 'cmmmmm 10/8/2019 18:00:40'!
 new

	^uniqueInstance ! !

PuntoCardinal subclass: #Sur
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRoverTDD'!

!classDefinition: #Sur category: #MarsRoverTDD stamp: 'LS 11/6/2019 16:25:58'!
PuntoCardinal subclass: #Sur
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRoverTDD'!
!Sur methodsFor: 'rotation' stamp: 'cmmmmm 10/10/2019 16:09:23'!
                  rotateLeft
	
	^Este new! !
!Sur methodsFor: 'rotation' stamp: 'cmmmmm 10/10/2019 16:10:13'!
    rotateRight
	
	^Oeste new! !
!Sur methodsFor: 'movement' stamp: 'LS 10/9/2019 20:47:37'!
       backward
	
	^(0@1)! !
!Sur methodsFor: 'movement' stamp: 'LS 10/9/2019 20:45:31'!
              forward

	^(0@-1)! !

"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!

Sur class
	instanceVariableNames: ''!

!classDefinition: 'Sur class' category: #MarsRoverTDD stamp: 'LS 11/6/2019 16:25:58'!
Sur class
	instanceVariableNames: ''!
!Sur class methodsFor: 'initialization' stamp: 'cmmmmm 10/8/2019 18:00:48'!
initialize

	uniqueInstance := self basicNew ! !
!Sur class methodsFor: 'initialization' stamp: 'cmmmmm 10/8/2019 18:00:54'!
   new

	^uniqueInstance ! !

PuntoCardinal initialize!

Este initialize!

Norte initialize!

Oeste initialize!

Sur initialize!

----End fileIn of /home/lsomacal/Escritorio/ejerciciosIS1/marsRover/MarsRoverTDD.st----!

Error subclass: #CantSuspend
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CodigoRepetido-Ejercicio'!

!classDefinition: #CantSuspend category: #'CodigoRepetido-Ejercicio' stamp: 'LS 11/6/2019 16:27:12'!
Error subclass: #CantSuspend
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CodigoRepetido-Ejercicio'!

Error subclass: #NotFound
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CodigoRepetido-Ejercicio'!

!classDefinition: #NotFound category: #'CodigoRepetido-Ejercicio' stamp: 'LS 11/6/2019 16:27:12'!
Error subclass: #NotFound
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CodigoRepetido-Ejercicio'!

TestCase subclass: #CustomerBookTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CodigoRepetido-Ejercicio'!

!classDefinition: #CustomerBookTest category: #'CodigoRepetido-Ejercicio' stamp: 'LS 11/6/2019 16:27:12'!
TestCase subclass: #CustomerBookTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CodigoRepetido-Ejercicio'!
!CustomerBookTest methodsFor: 'testing' stamp: 'cmmmmm 9/9/2019 16:33:20'!
              test01AddingCustomerShouldNotTakeMoreThan50Milliseconds

	| customerBook JohnLennon |
	
	customerBook := CustomerBook new.
	JohnLennon := 'John Lennon'.
	
	self testClosure: [customerBook addCustomerNamed: JohnLennon] withTime: (50*millisecond).
	
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'cmmmmm 9/9/2019 16:33:28'!
                         test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds

	| customerBook paulMcCartney |
	
	customerBook := CustomerBook new.
	paulMcCartney := 'Paul McCartney'.
	
	self testClosure: [customerBook addCustomerNamed: paulMcCartney] withTime: (100*millisecond).
	

	
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'cmmmmm 9/9/2019 16:49:42'!
      test03CanNotAddACustomerWithEmptyName 

	| customerBook |
			
	customerBook := CustomerBook new.

	self failing: [customerBook addCustomerNamed: ''] 
		withErrorType: Error
		assert: [ :anError | 
			self assert: anError messageText = CustomerBook customerCanNotBeEmptyErrorMessage.
			self assert: customerBook isEmpty ]
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'cmmmmm 9/9/2019 16:49:34'!
               test04CanNotRemoveAnInvalidCustomer
	
	| customerBook johnLennon |
			
	customerBook := CustomerBook new.
	johnLennon := 'John Lennon'.
	customerBook addCustomerNamed: johnLennon.
	
	self failing: [customerBook removeCustomerNamed: 'Paul McCartney'.]
		withErrorType: NotFound 
		assert: [ :anError | 
			self assert: customerBook numberOfCustomers = 1.
			self assert: (customerBook includesCustomerNamed: johnLennon) ]

! !
!CustomerBookTest methodsFor: 'testing' stamp: 'cmmmmm 9/9/2019 16:50:02'!
           test05SuspendingACustomerShouldNotRemoveItFromCustomerBook

	| customerBook paulMcCartney|
	
	customerBook := CustomerBook new.
	paulMcCartney := 'Paul McCartney'.
	
	customerBook addAndSuspend: paulMcCartney.
	
	self assertNumberOfActive: 0 suspended: 1 ofCustomerBook: customerBook.
	
	self assert: (customerBook includesCustomerNamed: paulMcCartney). 
	

	
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'cmmmmm 9/9/2019 16:39:06'!
         test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook

	| customerBook paulMcCartney|
	
	customerBook := CustomerBook new.
	paulMcCartney := 'Paul McCartney'.
	
	customerBook addAndSuspend: paulMcCartney.
	customerBook removeCustomerNamed: paulMcCartney.
	
	self assertNumberOfActive: 0 suspended: 0 ofCustomerBook: customerBook.
	self deny: (customerBook includesCustomerNamed: paulMcCartney).
	

	
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'cmmmmm 9/9/2019 17:04:08'!
                        test07CanNotSuspendAnInvalidCustomer
	
	| customerBook johnLennon paulMcCartney |
			
	customerBook := CustomerBook new.
	johnLennon := 'John Lennon'.
	paulMcCartney := 'Paul McCartney'.
	customerBook addCustomerNamed: johnLennon.
	
	self cannotSuspendCustomer: paulMcCartney in: customerBook with: johnLennon .
	

! !
!CustomerBookTest methodsFor: 'testing' stamp: 'cmmmmm 9/9/2019 16:55:54'!
                      test08CanNotSuspendAnAlreadySuspendedCustomer
	
	| customerBook johnLennon |
			
	customerBook := CustomerBook new.
	johnLennon := 'John Lennon'.
	customerBook addAndSuspend: johnLennon.
	
	self cannotSuspendCustomer: johnLennon in: customerBook .
! !
!CustomerBookTest methodsFor: 'codigoRepetido' stamp: 'cmmmmm 9/6/2019 17:57:34'!
                  assertNumberOfActive: aNumberOfActives suspended: aNumberOfSuspended ofCustomerBook: aCustomerBook

	| aNumberOfTotalCustomer |
	aNumberOfTotalCustomer := aNumberOfActives + aNumberOfSuspended. 
	self assert: aNumberOfActives equals: aCustomerBook numberOfActiveCustomers.
	self assert: aNumberOfSuspended equals: aCustomerBook numberOfSuspendedCustomers.
	self assert: aNumberOfTotalCustomer equals: aCustomerBook numberOfCustomers.
! !
!CustomerBookTest methodsFor: 'codigoRepetido' stamp: 'cmmmmm 9/6/2019 17:55:21'!
                        assertNumberOfActive: aNumberOfActives suspended: aNumberOfSuspended totalCustomers: aNumberOfTotalCustomers ofCustomerBook: aCustomerBook

	self assert: aNumberOfActives equals: aCustomerBook numberOfActiveCustomers.
	self assert: aNumberOfSuspended equals: aCustomerBook numberOfSuspendedCustomers.
	self assert: aNumberOfTotalCustomers equals: aCustomerBook numberOfCustomers.
! !
!CustomerBookTest methodsFor: 'codigoRepetido' stamp: 'cmmmmm 9/6/2019 17:48:54'!
              assertNumberOfActive: aNumberOfActives suspended: aNumberOfSuspended totalCustomers: aNumberOfTotalCustomers ofCustomerBook: aCustomerBook withCustomer: aCustomer

	self assert: aNumberOfActives equals: aCustomerBook numberOfActiveCustomers.
	self assert: aNumberOfSuspended equals: aCustomerBook numberOfSuspendedCustomers.
	self assert: aNumberOfTotalCustomers equals: aCustomerBook numberOfCustomers.
	self deny: (aCustomerBook includesCustomerNamed: aCustomer ).! !
!CustomerBookTest methodsFor: 'codigoRepetido' stamp: 'cmmmmm 9/9/2019 17:03:59'!
                        cannotSuspendCustomer: aCustomer in: aCustomerBook

 self cannotSuspendCustomer: aCustomer in: aCustomerBook with: aCustomer.! !
!CustomerBookTest methodsFor: 'codigoRepetido' stamp: 'cmmmmm 9/9/2019 17:03:15'!
             cannotSuspendCustomer: aCustomer in: aCustomerBook with: anotherCustomer
	
	
	[aCustomerBook suspendCustomerNamed: aCustomer.
	self fail ]
		on: CantSuspend 
		do: [ :anError | 
			self assert: aCustomerBook numberOfCustomers = 1.
			self assert: (aCustomerBook includesCustomerNamed: anotherCustomer ) ]! !
!CustomerBookTest methodsFor: 'codigoRepetido' stamp: 'LS 9/2/2019 21:51:33'!
                              failing: aFailingBlock withErrorType: anErrorType assert: assertingBlock

	[ aFailingBlock value. self fail ]
		on: anErrorType 
		do: assertingBlock.! !
!CustomerBookTest methodsFor: 'codigoRepetido' stamp: 'cmmmmm 9/9/2019 16:32:57'!
                    testClosure: aClosure withTime: aTime

		| millisecondsBeforeRunning millisecondsAfterRunning |

	millisecondsBeforeRunning := Time millisecondClockValue * millisecond.
	aClosure value.
	millisecondsAfterRunning := Time millisecondClockValue * millisecond.

	self assert: (millisecondsAfterRunning-millisecondsBeforeRunning) < (aTime)
! !

Object subclass: #CustomerBook
	instanceVariableNames: 'suspended active'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CodigoRepetido-Ejercicio'!

!classDefinition: #CustomerBook category: #'CodigoRepetido-Ejercicio' stamp: 'LS 11/6/2019 16:27:13'!
Object subclass: #CustomerBook
	instanceVariableNames: 'suspended active'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CodigoRepetido-Ejercicio'!
!CustomerBook methodsFor: 'testing' stamp: 'NR 4/3/2019 10:14:26'!
    includesCustomerNamed: aName

	^(active includes: aName) or: [ suspended includes: aName ]! !
!CustomerBook methodsFor: 'testing' stamp: 'NR 4/3/2019 10:14:26'!
                               isEmpty
	
	^active isEmpty and: [ suspended isEmpty ]! !
!CustomerBook methodsFor: 'initialization' stamp: 'NR 4/3/2019 10:14:26'!
                             initialize

	super initialize.
	active := OrderedCollection new.
	suspended:= OrderedCollection new.! !
!CustomerBook methodsFor: 'customer management' stamp: 'cmmmmm 9/9/2019 16:33:52'!
     addAndSuspend: aCustomer

	self addCustomerNamed: aCustomer. 
	self suspendCustomerNamed: aCustomer.! !
!CustomerBook methodsFor: 'customer management' stamp: 'NR 4/3/2019 10:14:26'!
         addCustomerNamed: aName

	aName isEmpty ifTrue: [ self signalCustomerNameCannotBeEmpty ].
	((active includes: aName) or: [suspended includes: aName]) ifTrue: [ self signalCustomerAlreadyExists ].
	
	active add: aName ! !
!CustomerBook methodsFor: 'customer management' stamp: 'NR 4/3/2019 10:14:26'!
                    numberOfActiveCustomers
	
	^active size! !
!CustomerBook methodsFor: 'customer management' stamp: 'NR 4/3/2019 10:14:26'!
      numberOfCustomers
	
	^active size + suspended size! !
!CustomerBook methodsFor: 'customer management' stamp: 'NR 9/19/2018 17:36:09'!
                          numberOfSuspendedCustomers
	
	^suspended size! !
!CustomerBook methodsFor: 'customer management' stamp: 'NR 4/3/2019 10:14:26'!
removeCustomerNamed: aName 
 
	1 to: active size do: 
	[ :index |
		aName = (active at: index)
			ifTrue: [
				active removeAt: index.
				^ aName 
			] 
	].

	1 to: suspended size do: 	
	[ :index |
		aName = (suspended at: index)
			ifTrue: [
				suspended removeAt: index.
				^ aName 
			] 
	].
	
	^ NotFound signal.
! !
!CustomerBook methodsFor: 'customer management' stamp: 'HernanWilkinson 7/6/2011 17:52'!
  signalCustomerAlreadyExists 

	self error: self class customerAlreadyExistsErrorMessage! !
!CustomerBook methodsFor: 'customer management' stamp: 'HernanWilkinson 7/6/2011 17:51'!
            signalCustomerNameCannotBeEmpty 

	self error: self class customerCanNotBeEmptyErrorMessage ! !
!CustomerBook methodsFor: 'customer management' stamp: 'NR 4/3/2019 10:14:26'!
                 suspendCustomerNamed: aName 
	
	(active includes: aName) ifFalse: [^CantSuspend signal].
	
	active remove: aName.
	
	suspended add: aName
! !

"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!

CustomerBook class
	instanceVariableNames: ''!

!classDefinition: 'CustomerBook class' category: #'CodigoRepetido-Ejercicio' stamp: 'LS 11/6/2019 16:27:13'!
CustomerBook class
	instanceVariableNames: ''!
!CustomerBook class methodsFor: 'error messages' stamp: 'NR 9/2/2019 14:41:10'!
                          customerAlreadyExistsErrorMessage

	^'Customer Already Exists.'! !
!CustomerBook class methodsFor: 'error messages' stamp: 'NR 9/2/2019 14:41:16'!
             customerCanNotBeEmptyErrorMessage

	^'Customer Name Cannot Be Empty.'! !

----End fileIn of /home/lsomacal/Escritorio/ejerciciosIS1/codigoRepetido/CodigoRepetido-Ejercicio.st----!

TestCase subclass: #NumeroTest
	instanceVariableNames: 'zero one two four oneFifth oneHalf five twoFifth twoTwentyfifth fiveHalfs three eight negativeOne negativeTwo'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Exercise'!

!classDefinition: #NumeroTest category: #'Numero-Exercise' stamp: 'LS 11/6/2019 16:28:08'!
TestCase subclass: #NumeroTest
	instanceVariableNames: 'zero one two four oneFifth oneHalf five twoFifth twoTwentyfifth fiveHalfs three eight negativeOne negativeTwo'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Exercise'!
!NumeroTest methodsFor: 'tests' stamp: 'HernanWilkinson 5/7/2016 20:11'!
test01isCeroReturnsTrueWhenAskToZero

	self assert: zero isZero! !
!NumeroTest methodsFor: 'tests' stamp: 'HernanWilkinson 5/7/2016 20:12'!
                    test02isCeroReturnsFalseWhenAskToOthersButZero

	self deny: one isZero! !
!NumeroTest methodsFor: 'tests' stamp: 'HernanWilkinson 5/7/2016 20:13'!
             test03isOneReturnsTrueWhenAskToOne

	self assert: one isOne! !
!NumeroTest methodsFor: 'tests' stamp: 'HernanWilkinson 5/7/2016 20:13'!
                        test04isOneReturnsFalseWhenAskToOtherThanOne

	self deny: zero isOne! !
!NumeroTest methodsFor: 'tests' stamp: 'HernanWilkinson 5/7/2016 20:14'!
               test05EnteroAddsWithEnteroCorrectly

	self assert: one + one equals: two! !
!NumeroTest methodsFor: 'tests' stamp: 'HernanWilkinson 5/7/2016 20:18'!
           test06EnteroMultipliesWithEnteroCorrectly

	self assert: two * two equals: four! !
!NumeroTest methodsFor: 'tests' stamp: 'HernanWilkinson 5/7/2016 20:20'!
    test07EnteroDividesEnteroCorrectly

	self assert: two / two equals: one! !
!NumeroTest methodsFor: 'tests' stamp: 'HernanWilkinson 5/7/2016 20:38'!
            test08FraccionAddsWithFraccionCorrectly
"
    La suma de fracciones es:
	 
	a/b + c/d = (a.d + c.b) / (b.d)
	 
	SI ESTAN PENSANDO EN LA REDUCCION DE FRACCIONES NO SE PREOCUPEN!!
	TODAVIA NO SE ESTA TESTEANDO ESE CASO
"
	| sevenTenths |

	sevenTenths := (Entero with: 7) / (Entero with: 10).

	self assert: oneFifth + oneHalf equals: sevenTenths! !
!NumeroTest methodsFor: 'tests' stamp: 'HernanWilkinson 5/7/2016 20:52'!
                           test09FraccionMultipliesWithFraccionCorrectly
"
    La multiplicacion de fracciones es:
	 
	(a/b) * (c/d) = (a.c) / (b.d)
"

	self assert: oneFifth * twoFifth equals: twoTwentyfifth! !
!NumeroTest methodsFor: 'tests' stamp: 'HernanWilkinson 5/7/2016 20:56'!
                              test10FraccionDividesFraccionCorrectly
"
    La division de fracciones es:
	 
	(a/b) / (c/d) = (a.d) / (b.c)
"

	self assert: oneHalf / oneFifth equals: fiveHalfs! !
!NumeroTest methodsFor: 'tests' stamp: 'HernanWilkinson 5/7/2016 21:07'!
                 test11EnteroAddsFraccionCorrectly
"
	Ahora empieza la diversion!!
"

	self assert: one + oneFifth equals: (Entero with: 6) / (Entero with: 5)! !
!NumeroTest methodsFor: 'tests' stamp: 'HernanWilkinson 5/7/2016 21:07'!
      test12FraccionAddsEnteroCorrectly

	self assert: oneFifth + one equals: (Entero with: 6) / (Entero with: 5)! !
!NumeroTest methodsFor: 'tests' stamp: 'HernanWilkinson 5/7/2016 21:50'!
        test13EnteroMultipliesFraccionCorrectly

	self assert: two * oneFifth equals: twoFifth ! !
!NumeroTest methodsFor: 'tests' stamp: 'HernanWilkinson 5/7/2016 21:52'!
                            test14FraccionMultipliesEnteroCorrectly

	self assert: oneFifth * two equals: twoFifth ! !
!NumeroTest methodsFor: 'tests' stamp: 'HernanWilkinson 5/7/2016 21:57'!
                            test15EnteroDividesFraccionCorrectly

	self assert: one / twoFifth equals: fiveHalfs  ! !
!NumeroTest methodsFor: 'tests' stamp: 'HernanWilkinson 5/7/2016 21:59'!
                             test16FraccionDividesEnteroCorrectly

	self assert: twoFifth / five equals: twoTwentyfifth ! !
!NumeroTest methodsFor: 'tests' stamp: 'HernanWilkinson 5/7/2016 22:38'!
                        test17AFraccionCanBeEqualToAnEntero

	self assert: two equals: four / two! !
!NumeroTest methodsFor: 'tests' stamp: 'HernanWilkinson 5/7/2016 22:39'!
          test18AparentFraccionesAreEqual

	self assert: oneHalf equals: two / four! !
!NumeroTest methodsFor: 'tests' stamp: 'HernanWilkinson 5/7/2016 22:40'!
          test19AddingFraccionesCanReturnAnEntero

	self assert: oneHalf + oneHalf equals: one! !
!NumeroTest methodsFor: 'tests' stamp: 'HernanWilkinson 5/7/2016 22:42'!
                               test20MultiplyingFraccionesCanReturnAnEntero

	self assert: (two/five) * (five/two) equals: one! !
!NumeroTest methodsFor: 'tests' stamp: 'HernanWilkinson 5/7/2016 22:42'!
                    test21DividingFraccionesCanReturnAnEntero

	self assert: oneHalf / oneHalf equals: one! !
!NumeroTest methodsFor: 'tests' stamp: 'HernanWilkinson 5/7/2016 22:43'!
                             test22DividingEnterosCanReturnAFraccion

	self assert: two / four equals: oneHalf! !
!NumeroTest methodsFor: 'tests' stamp: 'HernanWilkinson 5/7/2016 22:46'!
  test23CanNotDivideEnteroByZero

	self 
		should: [ one / zero ]
		raise: Error
		withExceptionDo: [ :anError | self assert: anError messageText equals: Numero canNotDivideByZeroErrorDescription ]
	! !
!NumeroTest methodsFor: 'tests' stamp: 'HernanWilkinson 5/7/2016 22:46'!
              test24CanNotDivideFraccionByZero

	self 
		should: [ oneHalf / zero ]
		raise: Error
		withExceptionDo: [ :anError | self assert: anError messageText equals: Numero canNotDivideByZeroErrorDescription ]
	! !
!NumeroTest methodsFor: 'tests' stamp: 'HernanWilkinson 5/7/2016 22:50'!
        test25AFraccionCanNotBeZero

	self deny: oneHalf isZero! !
!NumeroTest methodsFor: 'tests' stamp: 'HernanWilkinson 5/7/2016 22:50'!
                            test26AFraccionCanNotBeOne

	self deny: oneHalf isOne! !
!NumeroTest methodsFor: 'tests' stamp: 'NR 9/23/2018 23:47:26'!
       test27EnteroSubstractsEnteroCorrectly

	self assert: two - one equals: one! !
!NumeroTest methodsFor: 'tests' stamp: 'NR 9/23/2018 23:47:41'!
                  test28FraccionSubstractsFraccionCorrectly
	
	self assert: twoFifth - oneFifth equals: oneFifth.! !
!NumeroTest methodsFor: 'tests' stamp: 'NR 9/23/2018 23:48:00'!
                             test29EnteroSubstractsFraccionCorrectly

	self assert: one - oneHalf equals: oneHalf! !
!NumeroTest methodsFor: 'tests' stamp: 'HAW 9/24/2018 08:48:05'!
       test30FraccionSubstractsEnteroCorrectly

	| sixFifth |
	
	sixFifth := (Entero with: 6) / (Entero with: 5).
	
	self assert: sixFifth - one equals: oneFifth! !
!NumeroTest methodsFor: 'tests' stamp: 'HAW 9/24/2018 08:48:08'!
 test31SubstractingFraccionesCanReturnAnEntero

	| threeHalfs |
	
	threeHalfs := (Entero with: 3) / (Entero with: 2).
	
	self assert: threeHalfs - oneHalf equals: one.! !
!NumeroTest methodsFor: 'tests' stamp: 'NR 9/23/2018 23:48:48'!
                      test32SubstractingSameEnterosReturnsZero

	self assert: one - one equals: zero.! !
!NumeroTest methodsFor: 'tests' stamp: 'NR 9/23/2018 23:49:01'!
             test33SubstractingSameFraccionesReturnsZero

	self assert: oneHalf - oneHalf equals: zero.! !
!NumeroTest methodsFor: 'tests' stamp: 'HAW 9/24/2018 08:48:14'!
 test34SubstractingAHigherValueToANumberReturnsANegativeNumber

	| negativeThreeHalfs |
	
	negativeThreeHalfs := (Entero with: -3) / (Entero with: 2).	

	self assert: one - fiveHalfs equals: negativeThreeHalfs.! !
!NumeroTest methodsFor: 'tests' stamp: 'NR 9/23/2018 23:49:23'!
           test35FibonacciZeroIsOne

	self assert: zero fibonacci equals: one! !
!NumeroTest methodsFor: 'tests' stamp: 'NR 9/23/2018 23:49:32'!
                          test36FibonacciOneIsOne

	self assert: one fibonacci equals: one! !
!NumeroTest methodsFor: 'tests' stamp: 'NR 9/23/2018 23:49:39'!
                            test37FibonacciEnteroReturnsAddingPreviousTwoFibonacciEnteros

	self assert: four fibonacci equals: five.
	self assert: three fibonacci equals: three. 
	self assert: five fibonacci equals: four fibonacci + three fibonacci.! !
!NumeroTest methodsFor: 'tests' stamp: 'NR 9/23/2018 23:49:47'!
                              test38FibonacciNotDefinedForNegativeNumbers

	self 
		should: [negativeOne fibonacci]
		raise: Error
		withExceptionDo: [ :anError | self assert: anError messageText equals: Entero negativeFibonacciErrorDescription ].! !
!NumeroTest methodsFor: 'tests' stamp: 'NR 9/23/2018 23:49:55'!
   test39NegationOfEnteroIsCorrect

	self assert: two negated equals: negativeTwo.
		! !
!NumeroTest methodsFor: 'tests' stamp: 'NR 9/23/2018 23:50:03'!
          test40NegationOfFraccionIsCorrect

	self assert: oneHalf negated equals: negativeOne / two.! !
!NumeroTest methodsFor: 'tests' stamp: 'NR 9/23/2018 23:50:11'!
 test41SignIsCorrectlyAssignedToFractionWithTwoNegatives

	self assert: oneHalf equals: (negativeOne / negativeTwo)! !
!NumeroTest methodsFor: 'tests' stamp: 'NR 9/23/2018 23:50:17'!
          test42SignIsCorrectlyAssignedToFractionWithNegativeDivisor

	self assert: oneHalf negated equals: (one / negativeTwo)! !
!NumeroTest methodsFor: 'setup' stamp: 'NR 9/23/2018 23:46:28'!
       setUp

	zero := Entero with: 0.
	one := Entero with: 1.
	two := Entero with: 2.
	three:= Entero with: 3.
	four := Entero with: 4.
	five := Entero with: 5.
	eight := Entero with: 8.
	negativeOne := Entero with: -1.
	negativeTwo := Entero with: -2.
	
	oneHalf := one / two.
	oneFifth := one / five.
	twoFifth := two / five.
	twoTwentyfifth := two / (Entero with: 25).
	fiveHalfs := five / two.
	! !

Object subclass: #Numero
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Exercise'!

!classDefinition: #Numero category: #'Numero-Exercise' stamp: 'LS 11/6/2019 16:28:08'!
Object subclass: #Numero
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Exercise'!
!Numero methodsFor: 'arithmetic operations' stamp: 'HernanWilkinson 5/7/2016 22:48'!
     * aMultiplier

	self subclassResponsibility ! !
!Numero methodsFor: 'arithmetic operations' stamp: 'HernanWilkinson 5/7/2016 22:49'!
                           + anAdder

	self subclassResponsibility ! !
!Numero methodsFor: 'arithmetic operations' stamp: 'NR 9/23/2018 22:21:28'!
        - aSubtrahend

	self subclassResponsibility ! !
!Numero methodsFor: 'arithmetic operations' stamp: 'HernanWilkinson 5/7/2016 22:49'!
                           / aDivisor

	self subclassResponsibility ! !
!Numero methodsFor: 'arithmetic operations' stamp: 'HernanWilkinson 5/7/2016 22:48'!
                              invalidNumberType

	self error: self class invalidNumberTypeErrorDescription! !
!Numero methodsFor: 'arithmetic operations' stamp: 'NR 9/23/2018 23:37:13'!
    negated
	
	^self * (Entero with: -1)! !
!Numero methodsFor: 'testing' stamp: 'NR 9/23/2018 23:36:49'!
                          isNegative

	self subclassResponsibility ! !
!Numero methodsFor: 'testing' stamp: 'HernanWilkinson 5/7/2016 22:49'!
            isOne

	self subclassResponsibility ! !
!Numero methodsFor: 'testing' stamp: 'HernanWilkinson 5/7/2016 22:49'!
                 isZero

	self subclassResponsibility ! !

"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!

Numero class
	instanceVariableNames: ''!

!classDefinition: 'Numero class' category: #'Numero-Exercise' stamp: 'LS 11/6/2019 16:28:08'!
Numero class
	instanceVariableNames: ''!
!Numero class methodsFor: 'error descriptions' stamp: 'HernanWilkinson 5/7/2016 22:45'!
                  canNotDivideByZeroErrorDescription

	^'No se puede dividir por cero'! !
!Numero class methodsFor: 'error descriptions' stamp: 'NR 4/8/2019 02:58:13'!
          invalidNumberTypeErrorDescription
	^ 'Tipo de nmero invlido'! !

Numero subclass: #Entero
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Exercise'!

!classDefinition: #Entero category: #'Numero-Exercise' stamp: 'LS 11/6/2019 16:28:08'!
Numero subclass: #Entero
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Exercise'!
!Entero methodsFor: 'arithmetic operations' stamp: 'chris m 9/14/2019 18:01:33'!
          * aMultiplier 
	
	^aMultiplier multiplicacionConEntero: self.
	! !
!Entero methodsFor: 'arithmetic operations' stamp: 'chris m 9/14/2019 17:34:00'!
            + anAdder 
	
	^anAdder sumaConEntero: self.
	
	! !
!Entero methodsFor: 'arithmetic operations' stamp: 'chris m 9/14/2019 17:52:19'!
                            - aSubtrahend 
	
	^self + aSubtrahend negated.! !
!Entero methodsFor: 'arithmetic operations' stamp: 'LS 9/16/2019 01:36:35'!
  / aDivisor 
	
	"(aDivisor isKindOf: Fraccion ) ifTrue: [ ^Fraccion with: ( self * aDivisor denominator ) over: aDivisor numerator ]. "	
	
	^aDivisor dividiendoAUnEntero: self
	
	"^Fraccion with: self over: aDivisor"! !
!Entero methodsFor: 'arithmetic operations' stamp: 'HernanWilkinson 5/7/2016 21:55'!
                // aDivisor 
	
	^self class with: value // aDivisor integerValue! !
!Entero methodsFor: 'arithmetic operations' stamp: 'LS 9/16/2019 01:38:31'!
                dividiendoAUnEntero: unEntero

	^Fraccion with: unEntero over: self.! !
!Entero methodsFor: 'arithmetic operations' stamp: 'LS 9/16/2019 01:43:31'!
            dividiendoAUnaFraccion: unaFraccion

	^Fraccion with: (unaFraccion numerator) over: (unaFraccion denominator  * self).! !
!Entero methodsFor: 'arithmetic operations' stamp: 'HAW 9/24/2018 08:47:50'!
                         fibonacci

	| one two |
	
	one := Entero with: 1.
	two := Entero with: 2.
	
	self isNegative ifTrue: [self error: Entero negativeFibonacciErrorDescription ].	
	(self isZero or: [self isOne]) ifTrue: [^one].
	
	^ (self - one) fibonacci + (self - two) fibonacci
		! !
!Entero methodsFor: 'arithmetic operations' stamp: 'HernanWilkinson 5/7/2016 21:00'!
 greatestCommonDivisorWith: anEntero 
	
	^self class with: (value gcd: anEntero integerValue)! !
!Entero methodsFor: 'arithmetic operations' stamp: 'chris m 9/14/2019 17:58:37'!
               multiplicacionConEntero: unEntero

	^Entero with: ( value * unEntero integerValue ).
	

	! !
!Entero methodsFor: 'arithmetic operations' stamp: 'chris m 9/14/2019 18:00:02'!
                  multiplicacionConFraccion: unaFraccion

	^Fraccion with: ( unaFraccion numerator * self) over: unaFraccion denominator.
! !
!Entero methodsFor: 'arithmetic operations' stamp: 'chris m 9/14/2019 17:44:43'!
                   sumaConEntero: unSumandoEntero 
	
	 ^Entero with: value + unSumandoEntero integerValue.! !
!Entero methodsFor: 'arithmetic operations' stamp: 'chris m 9/14/2019 17:38:54'!
                    sumaConFraccion: unaFraccion
	
	 ^Fraccion with: ( unaFraccion numerator + (self * unaFraccion denominator )) over: unaFraccion denominator.! !
!Entero methodsFor: 'comparing' stamp: 'HernanWilkinson 5/7/2016 21:01'!
       = anObject

	^(anObject isKindOf: self class) and: [ value = anObject integerValue ]! !
!Entero methodsFor: 'comparing' stamp: 'HernanWilkinson 5/7/2016 20:17'!
                               hash

	^value hash! !
!Entero methodsFor: 'initialization' stamp: 'HernanWilkinson 5/7/2016 20:09'!
                            initalizeWith: aValue 
	
	value := aValue! !
!Entero methodsFor: 'value' stamp: 'HernanWilkinson 5/7/2016 21:02'!
              integerValue

	"Usamos integerValue en vez de value para que no haya problemas con el mensaje value implementado en Object - Hernan"
	
	^value! !
!Entero methodsFor: 'printing' stamp: 'HAW 9/24/2018 08:53:19'!
              printOn: aStream

	aStream print: value ! !
!Entero methodsFor: 'testing' stamp: 'NR 9/23/2018 22:17:55'!
                      isNegative
	
	^value < 0! !
!Entero methodsFor: 'testing' stamp: 'HernanWilkinson 5/7/2016 20:14'!
                             isOne
	
	^value = 1! !
!Entero methodsFor: 'testing' stamp: 'HernanWilkinson 5/7/2016 20:12'!
  isZero
	
	^value = 0! !

"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!

Entero class
	instanceVariableNames: ''!

!classDefinition: 'Entero class' category: #'Numero-Exercise' stamp: 'LS 11/6/2019 16:28:08'!
Entero class
	instanceVariableNames: ''!
!Entero class methodsFor: 'instance creation' stamp: 'NR 4/8/2019 02:57:57'!
              negativeFibonacciErrorDescription
	^ ' Fibonacci no est definido aqu para Enteros Negativos'! !
!Entero class methodsFor: 'instance creation' stamp: 'HernanWilkinson 5/7/2016 22:53'!
       with: aValue 
	
	"Esta verificacion esta puesta por si se equivocan y quieren crear un Entero pasando otra cosa que un Integer - Hernan"
	aValue isInteger ifFalse: [  self error: 'aValue debe ser anInteger' ].
	
	^self new initalizeWith: aValue! !

Numero subclass: #Fraccion
	instanceVariableNames: 'numerator denominator'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Exercise'!

!classDefinition: #Fraccion category: #'Numero-Exercise' stamp: 'LS 11/6/2019 16:28:08'!
Numero subclass: #Fraccion
	instanceVariableNames: 'numerator denominator'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Exercise'!
!Fraccion methodsFor: 'arithmetic operations' stamp: 'chris m 9/14/2019 18:01:50'!
            * aMultiplier 

	^aMultiplier multiplicacionConFraccion: self.

	! !
!Fraccion methodsFor: 'arithmetic operations' stamp: 'chris m 9/14/2019 17:39:32'!
        + anAdder 
	
	^anAdder sumaConFraccion: self. ! !
!Fraccion methodsFor: 'arithmetic operations' stamp: 'chris m 9/14/2019 17:54:33'!
                           - aSubtrahend 

	^self + aSubtrahend negated.
	! !
!Fraccion methodsFor: 'arithmetic operations' stamp: 'LS 9/16/2019 01:44:32'!
                               / aDivisor 

	"(aDivisor isKindOf: Entero ) ifTrue: [ ^Fraccion with: ( numerator) over: aDivisor  * denominator ]. 	
	
	^(numerator * aDivisor denominator) / (denominator * aDivisor numerator)"
	
	^aDivisor  dividiendoAUnaFraccion: self.! !
!Fraccion methodsFor: 'arithmetic operations' stamp: 'LS 9/16/2019 01:39:59'!
dividiendoAUnEntero: unEntero

	^Fraccion with: (unEntero * self denominator) over: self numerator .! !
!Fraccion methodsFor: 'arithmetic operations' stamp: 'LS 9/16/2019 01:42:39'!
          dividiendoAUnaFraccion: unaFraccion

	^Fraccion with: (unaFraccion numerator  * self denominator) over: (unaFraccion denominator  * self numerator).! !
!Fraccion methodsFor: 'arithmetic operations' stamp: 'chris m 9/14/2019 17:56:44'!
                     multiplicacionConEntero: unEntero

	^Fraccion with: ( unEntero * self numerator) over: self denominator
	

	! !
!Fraccion methodsFor: 'arithmetic operations' stamp: 'LS 9/15/2019 23:11:15'!
  multiplicacionConFraccion: unaFraccion

	^Fraccion with: ( self numerator * unaFraccion numerator) over: (self denominator * unaFraccion denominator).
	

	! !
!Fraccion methodsFor: 'arithmetic operations' stamp: 'chris m 9/14/2019 17:31:26'!
              sumaConEntero: unSumandoEntero 
	
	 ^Fraccion with: (self numerator + (unSumandoEntero * self denominator)) over: self denominator! !
!Fraccion methodsFor: 'arithmetic operations' stamp: 'chris m 9/14/2019 17:36:57'!
       sumaConFraccion: unaFraccion
	
	| newNumerator newDenominator |

	newNumerator := (numerator * unaFraccion denominator) + (denominator * unaFraccion numerator).
	newDenominator := denominator * unaFraccion denominator.
	
	^newNumerator / newDenominator ! !
!Fraccion methodsFor: 'comparing' stamp: 'HernanWilkinson 5/7/2016 20:42'!
                    = anObject

	^(anObject isKindOf: self class) and: [ (numerator * anObject denominator) = (denominator * anObject numerator) ]! !
!Fraccion methodsFor: 'comparing' stamp: 'HernanWilkinson 5/7/2016 20:50'!
                   hash

	^(numerator hash / denominator hash) hash! !
!Fraccion methodsFor: 'accessing' stamp: 'HernanWilkinson 5/7/2016 21:56'!
 denominator

	^ denominator! !
!Fraccion methodsFor: 'accessing' stamp: 'HernanWilkinson 5/7/2016 21:56'!
                      numerator

	^ numerator! !
!Fraccion methodsFor: 'initialization' stamp: 'HernanWilkinson 5/7/2016 22:54'!
                     initializeWith: aNumerator over: aDenominator

	"Estas precondiciones estan por si se comenten errores en la implementacion - Hernan"
	aNumerator isZero ifTrue: [ self error: 'una fraccion no puede ser cero' ].
	aDenominator isOne ifTrue: [ self error: 'una fraccion no puede tener denominador 1 porque sino es un entero' ].
	
	numerator := aNumerator.
	denominator := aDenominator ! !
!Fraccion methodsFor: 'testing' stamp: 'NR 9/23/2018 23:41:38'!
                              isNegative
	
	^numerator < 0! !
!Fraccion methodsFor: 'testing' stamp: 'HernanWilkinson 5/7/2016 22:51'!
                       isOne
	
	^false! !
!Fraccion methodsFor: 'testing' stamp: 'HernanWilkinson 5/7/2016 22:51'!
    isZero
	
	^false! !
!Fraccion methodsFor: 'printing' stamp: 'HAW 9/24/2018 08:54:46'!
          printOn: aStream

	aStream 
		print: numerator;
		nextPut: $/;
		print: denominator ! !

"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!

Fraccion class
	instanceVariableNames: ''!

!classDefinition: 'Fraccion class' category: #'Numero-Exercise' stamp: 'LS 11/6/2019 16:28:09'!
Fraccion class
	instanceVariableNames: ''!
!Fraccion class methodsFor: 'intance creation' stamp: 'NR 9/23/2018 23:45:19'!
      with: aDividend over: aDivisor

	| greatestCommonDivisor numerator denominator |
	
	aDivisor isZero ifTrue: [ self error: self canNotDivideByZeroErrorDescription ].
	aDividend isZero ifTrue: [ ^aDividend ].
	
	aDivisor isNegative ifTrue:[ ^aDividend negated / aDivisor negated].
	
	greatestCommonDivisor := aDividend greatestCommonDivisorWith: aDivisor. 
	numerator := aDividend // greatestCommonDivisor.
	denominator := aDivisor // greatestCommonDivisor.
	
	denominator isOne ifTrue: [ ^numerator ].

	^self new initializeWith: numerator over: denominator
	! !

----End fileIn of /home/lsomacal/Escritorio/ejerciciosIS1/eliminarIfs/Numero-Exercise.st----!

!classDefinition: #CashierTest category: #TusLibros stamp: 'LS 11/6/2019 16:29:05'!
TestCase subclass: #CashierTest
	instanceVariableNames: 'catalog'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #CashierTest category: #TusLibros stamp: 'LS 11/6/2019 16:29:06'!
TestCase subclass: #CashierTest
	instanceVariableNames: 'catalog cashier'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #CashierTest category: #TusLibros stamp: 'LS 11/6/2019 16:29:56'!
TestCase subclass: #CashierTest
	instanceVariableNames: 'catalog cashier currentDate'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!CashierTest methodsFor: 'as yet unclassified' stamp: 'LS 11/6/2019 16:29:49'!
             setUp

	catalog := Dictionary new.
	cashier := Cashier with: OrderedCollection new onDate: currentDate.
	
	
		
		 ! !

!classDefinition: #CashierTest category: #TusLibros stamp: 'LS 11/6/2019 16:30:49'!
TestCase subclass: #CashierTest
	instanceVariableNames: 'catalog cashier currentDate cart'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classRemoval: #Fraccion stamp: 'LS 11/6/2019 16:31:37'!
Numero subclass: #Fraccion
	instanceVariableNames: 'numerator denominator'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Exercise'!

!classRemoval: #Entero stamp: 'LS 11/6/2019 16:31:37'!
Numero subclass: #Entero
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Exercise'!

!classRemoval: #Numero stamp: 'LS 11/6/2019 16:31:37'!
Object subclass: #Numero
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Exercise'!

!classRemoval: #NumeroTest stamp: 'LS 11/6/2019 16:31:38'!
TestCase subclass: #NumeroTest
	instanceVariableNames: 'zero one two four oneFifth oneHalf five twoFifth twoTwentyfifth fiveHalfs three eight negativeOne negativeTwo'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Exercise'!

!classRemoval: #CustomerBook stamp: 'LS 11/6/2019 16:31:42'!
Object subclass: #CustomerBook
	instanceVariableNames: 'suspended active'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CodigoRepetido-Ejercicio'!

!classRemoval: #CustomerBookTest stamp: 'LS 11/6/2019 16:31:43'!
TestCase subclass: #CustomerBookTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CodigoRepetido-Ejercicio'!

!classRemoval: #NotFound stamp: 'LS 11/6/2019 16:31:43'!
Error subclass: #NotFound
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CodigoRepetido-Ejercicio'!

!classRemoval: #CantSuspend stamp: 'LS 11/6/2019 16:31:43'!
Error subclass: #CantSuspend
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CodigoRepetido-Ejercicio'!
!CashierTest methodsFor: 'as yet unclassified' stamp: 'LS 11/6/2019 16:32:02' prior: 50337426!
                              setUp

	catalog := Dictionary new.
	cashier := Cashier with: OrderedCollection new onDate: currentDate.
	cart := Cart acceptingItemsOf: catalog.
	
		
		 ! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'LS 11/6/2019 16:32:38' prior: 50334941!
    test04CannotCheckoutACartWithAnExpiredCreditCard

	| aCard anExpiredDate |
	
	anExpiredDate := GregorianMonthOfYear decemberOf: 2018.
	currentDate := GregorianMonthOfYear decemberOf: 2019.
	
	aCard := CreditCard withNumber: (10 raisedToInteger: 15) expirationDate: anExpiredDate owner: 'San Martin'.
	
	catalog add:'validBook'->100.
	
	cart add: 'validBook'.	

	self should: [ cashier checkOut: cart withCard: aCard ]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [ :anError |
			self assert: anError messageText = Cashier creditCardExpired .
			]
		
		 ! !

!testRun: #CashierTest #test04CannotCheckoutACartWithAnExpiredCreditCard stamp: 'LS 11/6/2019 16:32:51'!
ERROR!

!testRun: #CashierTest #test04CannotCheckoutACartWithAnExpiredCreditCard stamp: 'LS 11/6/2019 16:33:29'!
ERROR!
!CashierTest methodsFor: 'as yet unclassified' stamp: 'LS 11/6/2019 16:34:00' prior: 50337503!
      test04CannotCheckoutACartWithAnExpiredCreditCard

	| aCard anExpiredDate |
	
	anExpiredDate := GregorianMonthOfYear decemberOf: 2018.
	
	aCard := CreditCard withNumber: (10 raisedToInteger: 15) expirationDate: anExpiredDate owner: 'San Martin'.
	
	catalog add:'validBook'->100.
	
	cart add: 'validBook'.	

	self should: [ cashier checkOut: cart withCard: aCard ]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [ :anError |
			self assert: anError messageText = Cashier creditCardExpired .
			]
		
		 ! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'LS 11/6/2019 16:34:25' prior: 50337495!
                               setUp

	currentDate := GregorianMonthOfYear decemberOf: 2019.
	
	catalog := Dictionary new.
	cashier := Cashier with: OrderedCollection new onDate: currentDate.
	cart := Cart acceptingItemsOf: catalog.
	
		
		 ! !

!testRun: #CashierTest #test04CannotCheckoutACartWithAnExpiredCreditCard stamp: 'LS 11/6/2019 16:36:11'!
PASSED!

!testRun: #CashierTest #test01NewCashierWith stamp: 'LS 11/6/2019 16:36:11'!
PASSED!

!testRun: #CashierTest #test02CheckoutACartWith1ElementIsCorrect stamp: 'LS 11/6/2019 16:36:11'!
PASSED!

!testRun: #CashierTest #test03CheckoutACartWithSeveralElementGivesCorrectSubtotal stamp: 'LS 11/6/2019 16:36:11'!
PASSED!

!testRun: #CashierTest #test04CannotCheckoutACartWithAnExpiredCreditCard stamp: 'LS 11/6/2019 16:36:11'!
PASSED!
!CashierTest methodsFor: 'testing' stamp: 'LS 11/6/2019 16:36:57' prior: 50335383!
                        test03CheckoutACartWithSeveralElementGivesCorrectSubtotal

	catalog add:'validBook'->100; add:'validBook2'->50.
	
	cashier := Cashier with: Array new.
	
	cart add: 'validBook'.
	cart add: 'validBook2'.
	
	self assert: 150 equals: (cashier checkOut: cart) .	

		
		 ! !

!testRun: #CashierTest #test03CheckoutACartWithSeveralElementGivesCorrectSubtotal stamp: 'LS 11/6/2019 16:36:58'!
PASSED!

!testRun: #CashierTest #test01NewCashierWith stamp: 'LS 11/6/2019 16:36:58'!
PASSED!

!testRun: #CashierTest #test02CheckoutACartWith1ElementIsCorrect stamp: 'LS 11/6/2019 16:36:58'!
PASSED!

!testRun: #CashierTest #test03CheckoutACartWithSeveralElementGivesCorrectSubtotal stamp: 'LS 11/6/2019 16:36:58'!
PASSED!

!testRun: #CashierTest #test04CannotCheckoutACartWithAnExpiredCreditCard stamp: 'LS 11/6/2019 16:36:58'!
PASSED!
!CashierTest methodsFor: 'testing' stamp: 'LS 11/6/2019 16:37:32' prior: 50335323!
                        test02CheckoutACartWith1ElementIsCorrect
	
	catalog add:'validBook'->100.
	
	cart add: 'validBook'.
	
	self assert: 100 equals: (cashier checkOut: cart) .	

		
		 ! !

!testRun: #CashierTest #test02CheckoutACartWith1ElementIsCorrect stamp: 'LS 11/6/2019 16:37:34'!
PASSED!

!testRun: #CashierTest #test01NewCashierWith stamp: 'LS 11/6/2019 16:37:34'!
PASSED!

!testRun: #CashierTest #test02CheckoutACartWith1ElementIsCorrect stamp: 'LS 11/6/2019 16:37:34'!
PASSED!

!testRun: #CashierTest #test03CheckoutACartWithSeveralElementGivesCorrectSubtotal stamp: 'LS 11/6/2019 16:37:34'!
PASSED!

!testRun: #CashierTest #test04CannotCheckoutACartWithAnExpiredCreditCard stamp: 'LS 11/6/2019 16:37:34'!
PASSED!
!CashierTest methodsFor: 'testing' stamp: 'LS 11/6/2019 16:38:02' prior: 50335353!
               test01NewCashierWith
	
	cart := Cart acceptingItemsOf: (Dictionary with: 'validBook'->100).
		
	self should: [ cashier checkOut: cart ]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [ :anError |
			self assert: anError messageText = Cashier cartCanNotBeEmpty.
			]
		
		 ! !

!testRun: #CashierTest #test01NewCashierWith stamp: 'LS 11/6/2019 16:38:03'!
PASSED!

!testRun: #CashierTest #test01NewCashierWith stamp: 'LS 11/6/2019 16:38:03'!
PASSED!

!testRun: #CashierTest #test02CheckoutACartWith1ElementIsCorrect stamp: 'LS 11/6/2019 16:38:03'!
PASSED!

!testRun: #CashierTest #test03CheckoutACartWithSeveralElementGivesCorrectSubtotal stamp: 'LS 11/6/2019 16:38:03'!
PASSED!

!testRun: #CashierTest #test04CannotCheckoutACartWithAnExpiredCreditCard stamp: 'LS 11/6/2019 16:38:03'!
PASSED!
!CashierTest methodsFor: 'testing' stamp: 'LS 11/6/2019 16:38:54' prior: 50337531!
            test04CannotCheckoutACartWithAnExpiredCreditCard

	| anExpiredCard anExpiredDate |
	
	anExpiredDate := GregorianMonthOfYear decemberOf: 2018.
	
	anExpiredCard := CreditCard withNumber: (10 raisedToInteger: 15) expirationDate: anExpiredDate owner: 'San Martin'.
	
	catalog add:'validBook'->100.
	
	cart add: 'validBook'.	

	self should: [ cashier checkOut: cart withCard: anExpiredCard ]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [ :anError |
			self assert: anError messageText = Cashier creditCardExpired .
			]
		
		 ! !

!classDefinition: #CashierTest category: #TusLibros stamp: 'LS 11/6/2019 16:41:07'!
TestCase subclass: #CashierTest
	instanceVariableNames: 'catalog cashier currentDate cart card'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!CashierTest methodsFor: 'setUp/tearDown' stamp: 'LS 11/6/2019 16:41:03' prior: 50337551!
                 setUp

	| aValidExpirationDate aCurrentDate |

	aCurrentDate := GregorianMonthOfYear decemberOf: 2019.
	aValidExpirationDate := GregorianMonthOfYear decemberOf: 2020.
	
	catalog := Dictionary new.
	cashier := Cashier with: OrderedCollection new onDate: aCurrentDate.
	cart := Cart acceptingItemsOf: catalog.
	card := CreditCard withNumber: (10 raisedToInteger: 15) expirationDate: aValidExpirationDate owner: 'San Martin'.
		
		 ! !

!testRun: #CashierTest #test01NewCashierWith stamp: 'LS 11/6/2019 16:41:17'!
PASSED!

!testRun: #CashierTest #test02CheckoutACartWith1ElementIsCorrect stamp: 'LS 11/6/2019 16:41:17'!
PASSED!

!testRun: #CashierTest #test03CheckoutACartWithSeveralElementGivesCorrectSubtotal stamp: 'LS 11/6/2019 16:41:17'!
PASSED!

!testRun: #CashierTest #test04CannotCheckoutACartWithAnExpiredCreditCard stamp: 'LS 11/6/2019 16:41:17'!
PASSED!
!CashierTest methodsFor: 'testing' stamp: 'LS 11/6/2019 16:44:34' prior: 50337660!
               test04CannotCheckoutACartWithAnExpiredCreditCard

	| anExpiredCard anExpiredDate |
	
	anExpiredDate := GregorianMonthOfYear decemberOf: 2018.
	anExpiredCard := CreditCard withNumber: (10 raisedToInteger: 15) expirationDate: anExpiredDate owner: 'San Martin'.
	
	catalog add:'validBook'->100.
	
	cart add: 'validBook'.	

	self should: [ cashier checkOut: cart withCard: anExpiredCard ]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [ :anError |
			self assert: anError messageText = Cashier creditCardExpired .
			]
		
		 ! !

!testRun: #CashierTest #test04CannotCheckoutACartWithAnExpiredCreditCard stamp: 'LS 11/6/2019 16:44:35'!
PASSED!

!testRun: #CashierTest #test01NewCashierWith stamp: 'LS 11/6/2019 16:44:35'!
PASSED!

!testRun: #CashierTest #test02CheckoutACartWith1ElementIsCorrect stamp: 'LS 11/6/2019 16:44:35'!
PASSED!

!testRun: #CashierTest #test03CheckoutACartWithSeveralElementGivesCorrectSubtotal stamp: 'LS 11/6/2019 16:44:35'!
PASSED!

!testRun: #CashierTest #test04CannotCheckoutACartWithAnExpiredCreditCard stamp: 'LS 11/6/2019 16:44:35'!
PASSED!

TestCase subclass: #CashierTest
	instanceVariableNames: 'catalog cashier cart card'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #CashierTest category: #TusLibros stamp: 'LS 11/6/2019 16:44:46'!
TestCase subclass: #CashierTest
	instanceVariableNames: 'catalog cashier cart card'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!testRun: #CashierTest #test01NewCashierWith stamp: 'LS 11/6/2019 16:44:50'!
PASSED!

!testRun: #CashierTest #test02CheckoutACartWith1ElementIsCorrect stamp: 'LS 11/6/2019 16:44:50'!
PASSED!

!testRun: #CashierTest #test03CheckoutACartWithSeveralElementGivesCorrectSubtotal stamp: 'LS 11/6/2019 16:44:50'!
PASSED!

!testRun: #CashierTest #test04CannotCheckoutACartWithAnExpiredCreditCard stamp: 'LS 11/6/2019 16:44:50'!
PASSED!

----SNAPSHOT----(6 November 2019 17:17:21) CuisUniversity-3938.image priorSource: 14558761!

----QUIT----(6 November 2019 17:17:29) CuisUniversity-3938.image priorSource: 196141!

----STARTUP---- (6 November 2019 17:18:34) as /home/lsomacal/Escritorio/linux64/CuisUniversity-3938.image!


----QUIT----(6 November 2019 17:18:47) CuisUniversity-3938.image priorSource: 196234!